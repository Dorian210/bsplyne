MODULE: bsplyne.b_spline_basis
==============================
Documentation for module bsplyne.b_spline_basis

CLASS: BSplineBasis
--------------------
BSpline basis in 1D.

A class representing a one-dimensional B-spline basis with functionality for evaluation,
manipulation and visualization of basis functions. Provides methods for basis function
evaluation, derivatives computation, knot insertion, order elevation, and integration
point generation.

Attributes
----------
p : int
    Degree of the polynomials composing the basis.
knot : np.ndarray[np.floating]
    Knot vector defining the B-spline basis. Contains non-decreasing sequence
    of parametric coordinates.
m : int
    Last index of the knot vector (size - 1).
n : int
    Last index of the basis functions. When evaluated, returns an array of size
    `n + 1`.
span : tuple[float, float]
    Interval of definition of the basis `(knot[p], knot[m - p])`.

Notes
-----
The basis functions are defined over the parametric space specified by the knot vector.
Basis function evaluation and manipulation methods use efficient algorithms based on
Cox-de Boor recursion formulas.

See Also
--------
`numpy.ndarray` : Array type used for knot vector storage
`scipy.sparse` : Sparse matrix formats used for basis function evaluations

  >>> __init__(self, p: int, knot: Iterable[float])
      Initialize a B-spline basis with specified degree and knot vector.
      
      Parameters
      ----------
      p : int
          Degree of the B-spline polynomials.
      knot : Iterable[float]
          Knot vector defining the B-spline basis. Must be a non-decreasing sequence
          of real numbers.
      
      Returns
      -------
      BSplineBasis
          The initialized `BSplineBasis` instance.
      
      Notes
      -----
      The knot vector must satisfy these conditions:
      - Size must be at least `p + 2`
      - Must be non-decreasing
      - For non closed B-spline curves, first and last knots must have multiplicity `p + 1`
      
      The basis functions are defined over the parametric space specified by
      the knot vector. The span of the basis is [`knot[p]`, `knot[m - p]`], where
      `m` is the last index of the knot vector.
      
      Examples
      --------
      Create a quadratic B-spline basis with uniform knot vector:
      >>> basis = BSplineBasis(2, [0., 0., 0., 1., 1., 1.])

  >>> linspace(self, n_eval_per_elem: int = 10) -> numpy.ndarray[numpy.floating]
      Generate evenly spaced points over the basis span.
      
      Creates a set of evaluation points by distributing them uniformly within each knot span
      (element) of the basis. Points are evenly spaced within elements but spacing may vary
      between different elements.
      
      Parameters
      ----------
      n_eval_per_elem : int, optional
          Number of evaluation points per element. By default, 10.
      
      Returns
      -------
      xi : np.ndarray[np.floating]
          Array of evenly spaced points in parametric coordinates over the basis span.
      
      Notes
      -----
      The method:
      1. Identifies unique knot spans (elements) in the parametric space
      2. Distributes points evenly within each element
      3. Combines points from all elements into a single array
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0., 0., 0., 1., 1., 1.])
      >>> basis.linspace(5)
      array([0. , 0.2, 0.4, 0.6, 0.8, 1. ])

  >>> linspace_for_integration(
    self,
    n_eval_per_elem: int = 10,
    bounding_box: Optional[tuple[float, float]] = None
) -> tuple[numpy.ndarray[numpy.floating], numpy.ndarray[numpy.floating]]
      Generate points and weights for numerical integration over knot spans in the
      parametric space. Points are evenly distributed within each element (knot span),
      though spacing may vary between different elements.
      
      Parameters
      ----------
      n_eval_per_elem : int, optional
          Number of evaluation points per element. By default, 10.
      bounding_box : Union[tuple[float, float], None], optional
          Lower and upper bounds for integration. If `None`, uses the span of the basis.
          By default, None.
      
      Returns
      -------
      xi : np.ndarray[np.floating]
          Array of integration points in parametric coordinates, evenly spaced
          within each element.
      dxi : np.ndarray[np.floating]
          Array of corresponding integration weights, which may vary between elements
      
      Notes
      -----
      The method generates integration points by:
      1. Identifying unique knot spans (elements) in the parametric space
      2. Distributing points evenly within each element
      3. Computing appropriate weights for each point based on the element size
      
      When `bounding_box` is provided, integration is restricted to that interval,
      and elements are adjusted accordingly.
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0, 0, 0, 1, 1, 1])
      >>> xi, dxi = basis.linspace_for_integration(5)

  >>> gauss_legendre_for_integration(
    self,
    n_eval_per_elem: Optional[int] = None,
    bounding_box: Optional[tuple[float, float]] = None
) -> tuple[numpy.ndarray[numpy.floating], numpy.ndarray[numpy.floating]]
      Generate Gauss-Legendre quadrature points and weights for numerical integration over the B-spline basis.
      
      Parameters
      ----------
      n_eval_per_elem : Union[int, None], optional
          Number of evaluation points per element. If `None`, takes the value `self.p//2 + 1`.
          By default, None.
      bounding_box : Union[tuple[float, float], None], optional
          Lower and upper bounds for integration. If `None`, uses the span of the basis.
          By default, None.
      
      Returns
      -------
      xi : np.ndarray[np.floating]
          Array of Gauss-Legendre quadrature points in parametric coordinates.
      dxi : np.ndarray[np.floating]
          Array of corresponding integration weights.
      
      Notes
      -----
      The method generates integration points and weights by:
      1. Identifying unique knot spans (elements) in the parametric space
      2. Computing Gauss-Legendre points and weights for each element
      3. Transforming points and weights to account for element size
      
      When `bounding_box` is provided, integration is restricted to that interval.
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0, 0, 0, 1, 1, 1])
      >>> xi, dxi = basis.gauss_legendre_for_integration(3)
      >>> xi  # Gauss-Legendre points
      array([0.11270167, 0.5       , 0.88729833])
      >>> dxi  # Integration weights
      array([0.27777778, 0.44444444, 0.27777778])

  >>> normalize_knots(self)
      Normalize the knot vector to the interval [0, 1].
      
      Maps the knot vector to the unit interval by applying an affine transformation that
      preserves the relative spacing between knots. Updates both the knot vector and span
      attributes.
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0., 0., 0., 2., 2., 2.])
      >>> basis.normalize_knots()
      >>> basis.knot
      array([0., 0., 0., 1., 1., 1.])
      >>> basis.span
      (0, 1)

  >>> N(
    self,
    XI: numpy.ndarray[numpy.floating],
    k: int = 0
) -> scipy.sparse._coo.coo_matrix
      Compute the k-th derivative of the B-spline basis functions at specified points.
      
      Parameters
      ----------
      XI : np.ndarray[np.floating]
          Points in the parametric space at which to evaluate the basis functions.
      k : int, optional
          Order of the derivative to compute. By default, 0.
      
      Returns
      -------
      DN : sps.coo_matrix
          Sparse matrix containing the k-th derivative values. Each row corresponds to an
          evaluation point, each column to a basis function. Shape is (`XI.size`, `n + 1`).
      
      Notes
      -----
      Uses Cox-de Boor recursion formulas to compute basis function derivatives.
      Returns values in sparse matrix format for efficient storage and computation.
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0., 0., 0., 1., 1., 1.])
      >>> basis.N([0., 0.5, 1.]).A  # Evaluate basis functions
      array([[1.  , 0.  , 0.  ],
          [0.25, 0.5 , 0.25],
          [0.  , 0.  , 1.  ]])
      >>> basis.N([0., 0.5, 1.], k=1).A  # Evaluate first derivatives
      array([[-2.,  2.,  0.],
          [-1.,  0.,  1.],
          [ 0., -2.,  2.]])

  >>> to_dict(self) -> dict
      Returns a dictionary representation of the BSplineBasis object.

  >>> from_dict(cls, data: dict) -> bsplyne.b_spline_basis.BSplineBasis
      Creates a BSplineBasis object from a dictionary representation.

  >>> save(self, filepath: str) -> None
      Save the BSplineBasis object to a file.
      Control points are optional.
      Supported extensions: json, pkl

  >>> load(cls, filepath: str) -> bsplyne.b_spline_basis.BSplineBasis
      Load a BSplineBasis object from a file.
      May return control points if the file contains them.
      Supported extensions: json, pkl

  >>> plotN(self, k: int = 0, show: bool = True)
      Plot the B-spline basis functions or their derivatives over the span.
      
      Visualizes each basis function N_i(ξ) or its k-th derivative over its support interval
      using matplotlib. The plot includes proper LaTeX labels and a legend if there are 10 or
      fewer basis functions.
      
      Parameters
      ----------
      k : int, optional
          Order of derivative to plot. By default, 0 (plots the basis functions themselves).
      show : bool, optional
          Whether to display the plot immediately. Can be useful to add more stuff to the plot.
          By default, True.
      
      Notes
      -----
      - Uses adaptive sampling with points only in regions where basis functions are non-zero
      - Plots each basis function in a different color with LaTeX-formatted labels
      - Legend is automatically hidden if there are more than 10 basis functions
      - The x-axis represents the parametric coordinate ξ
      
      Examples
      --------
      >>> basis = BSplineBasis(2, [0., 0., 0., 1., 1., 1.])
      >>> basis.plotN()  # Plot basis functions
      >>> basis.plotN(k=1)  # Plot first derivatives

  >>> knotInsertion(
    self,
    knots_to_add: numpy.ndarray[numpy.floating]
) -> scipy.sparse._coo.coo_matrix
      Insert knots into the B-spline basis and return the transformation matrix.
      
      Parameters
      ----------
      knots_to_add : np.ndarray[np.floating]
          Array of knots to insert into the knot vector.
      
      Returns
      -------
      D : sps.coo_matrix
          Transformation matrix such that new control points = `D` @ old control points.
      
      Notes
      -----
      Updates the basis by:
      - Inserting new knots into the knot vector
      - Incrementing `m` and `n` by the number of inserted knots
      - Computing transformation matrix `D` for control points update
      
      Examples
      --------
      >>> basis = BSplineBasis(2, np.array([0, 0, 0, 1, 1, 1], dtype='float'))
      >>> basis.knotInsertion(np.array([0.33, 0.67], dtype='float')).A
      array([[1.    , 0.    , 0.    ],
             [0.67  , 0.33  , 0.    ],
             [0.2211, 0.5578, 0.2211],
             [0.    , 0.33  , 0.67  ],
             [0.    , 0.    , 1.    ]])
      
      The knot vector is modified (as well as n and m) :
      >>> basis.knot
      array([0.  , 0.  , 0.  , 0.33, 0.67, 1.  , 1.  , 1.  ])

  >>> orderElevation(self, t: int) -> scipy.sparse._coo.coo_matrix
      Elevate the polynomial degree of the B-spline basis and return the transformation matrix.
      
      Parameters
      ----------
      t : int
          Amount by which to increase the basis degree. New degree will be current degree plus `t`.
      
      Returns
      -------
      STD : sps.coo_matrix
          Transformation matrix for control points such that:
          new_control_points = `STD` @ old_control_points
      
      Notes
      -----
      The method:
      1. Separates B-spline into Bézier segments via knot insertion
      2. Elevates degree of each Bézier segment
      3. Recombines segments into elevated B-spline via knot removal
      4. Updates basis degree, knot vector and other attributes
      
      Examples
      --------
      Elevate quadratic basis to cubic:
      >>> basis = BSplineBasis(2, np.array([0, 0, 0, 1, 1, 1], dtype='float'))
      >>> basis.orderElevation(1).A
      array([[1.        , 0.        , 0.        ],
             [0.33333333, 0.66666667, 0.        ],
             [0.        , 0.66666667, 0.33333333],
             [0.        , 0.        , 1.        ]])
      
      The knot vector and the degree are modified (as well as n and m) :
      >>> basis.knot
      array([0., 0., 0., 0., 1., 1., 1., 1.])
      >>> basis.p
      3

  >>> greville_abscissa(
    self,
    return_weights: bool = False
) -> Union[numpy.ndarray[numpy.floating], tuple[numpy.ndarray[numpy.floating], numpy.ndarray[numpy.floating]]]
      Compute the Greville abscissa and optionally their weights for this 1D B-spline basis.
      
      The Greville abscissa represent the parametric coordinates associated with each
      control point. They are defined as the average of `p` consecutive internal knots.
      
      Parameters
      ----------
      return_weights : bool, optional
          If `True`, also returns the weights (support lengths) associated with each basis function.
          By default, False.
      
      Returns
      -------
      greville : np.ndarray[np.floating]
          Array containing the Greville abscissa of size `n + 1`, where `n` is the last index
          of the basis functions in this 1D basis.
      
      weight : np.ndarray[np.floating], optional
          Only returned if `return_weights` is `True`.
          Array of the same size as `greville`, containing the length of the support of
          each basis function (difference between the end and start knots of its support).
      
      Notes
      -----
      - The Greville abscissa are computed as the average of `p` consecutive knots:
        for the i-th basis function, its abscissa is
        (knot[i+1] + knot[i+2] + ... + knot[i+p]) / p
      - The weights represent the length of the support of each basis function,
        computed as knot[i+p+1] - knot[i].
      - The number of abscissa equals the number of control points.
      
      Examples
      --------
      >>> degree = 2
      >>> knot = np.array([0, 0, 0, 0.5, 1, 1, 1], dtype='float')
      >>> basis = BSplineBasis(degree, knot)
      >>> greville = basis.greville_abscissa()
      >>> greville
      array([0.  , 0.25, 0.75, 1.  ])
      
      Compute both abscissa and weights:
      >>> greville, weight = basis.greville_abscissa(return_weights=True)
      >>> weight
      array([0.5, 1. , 1. , 0.5])


GLOBAL FUNCTIONS:
~~~~~~~~~~~~~~~~~~