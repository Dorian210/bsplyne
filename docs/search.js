window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "bsplyne", "modulename": "bsplyne", "kind": "module", "doc": "<h1 id=\"bsplyne\">bsplyne</h1>\n\n<p align=\"center\">\n  <img src=docs/logo.png width=\"500\" />\n</p>\n\n<p><strong>bsplyne</strong> is a Python library for working with N-dimensional B-splines. It implements the Cox-de Boor algorithm for basis evaluation, order elevation, knot insertion, and provides a connectivity class for multi-patch structures. Additionally, it includes visualization tools with export capabilities to Paraview.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>Since <strong>bsplyne</strong> is not yet on PyPI, you can install it locally as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>git<span class=\"w\"> </span>clone<span class=\"w\"> </span>https://github.com/Dorian210/bsplyne\n<span class=\"nb\">cd</span><span class=\"w\"> </span>bsplyne\npip<span class=\"w\"> </span>install<span class=\"w\"> </span>-e<span class=\"w\"> </span>.\n</code></pre>\n</div>\n\n<h3 id=\"dependencies\">Dependencies</h3>\n\n<p>Make sure you have the following dependencies installed:</p>\n\n<ul>\n<li><code>numpy</code></li>\n<li><code>numba</code></li>\n<li><code>scipy</code></li>\n<li><code>matplotlib</code></li>\n<li><code>meshio</code></li>\n<li><code>tqdm</code></li>\n</ul>\n\n<h2 id=\"main-modules\">Main Modules</h2>\n\n<ul>\n<li><p><strong>BSplineBasis</strong><br />\nImplements B-spline basis function evaluation using the Cox-de Boor recursion formula.</p></li>\n<li><p><strong>BSpline</strong><br />\nProvides methods for creating and manipulating N-dimensional B-splines, including order elevation and knot insertion.</p></li>\n<li><p><strong>MultiPatchBSplineConnectivity</strong><br />\nManages the connectivity between multiple N-dimensional B-spline patches.</p></li>\n<li><p><strong>CouplesBSplineBorder</strong> (less documented)<br />\nHandles coupling between B-spline borders.</p></li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>Several example scripts demonstrating the usage of <strong>bsplyne</strong> can be found in the <code>examples/</code> directory. These scripts cover:</p>\n\n<ul>\n<li>Basis evaluation on a curved line</li>\n<li>Plotting with Matplotlib</li>\n<li>Order elevation</li>\n<li>Knot insertion</li>\n<li>Surface examples</li>\n<li>Exporting to Paraview</li>\n</ul>\n\n<h2 id=\"documentation\">Documentation</h2>\n\n<p>The full API documentation is available in the <code>docs/</code> directory of the project or via the <a href=\"https://dorian210.github.io/bsplyne/\">online documentation portal</a>.</p>\n\n<h2 id=\"contributions\">Contributions</h2>\n\n<p>At the moment, I am not actively reviewing contributions. However, if you encounter issues or have suggestions, feel free to open an issue.</p>\n\n<h2 id=\"license\">License</h2>\n\n<p>This project is licensed under the <a href=\"LICENSE.txt\">CeCILL License</a>.</p>\n"}, {"fullname": "bsplyne.b_spline", "modulename": "bsplyne.b_spline", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.b_spline.BSpline", "modulename": "bsplyne.b_spline", "qualname": "BSpline", "kind": "class", "doc": "<p>BSpline class for representing and manipulating B-spline curves, surfaces and volumes.</p>\n\n<p>A class providing functionality for evaluating, manipulating and visualizing B-splines of arbitrary dimension.\nSupports knot insertion, order elevation, and visualization through Paraview and Matplotlib.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>NPa</strong> (int):\nDimension of the isoparametric space.</li>\n<li><strong>bases</strong> (np.ndarray[BSplineBasis]):\nArray containing <code>BSplineBasis</code> instances for each isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Supports B-splines of arbitrary dimension (curves, surfaces, volumes, etc.)</li>\n<li>Provides methods for evaluation, derivatives, refinement and visualization</li>\n<li>Uses Cox-de Boor recursion formulas for efficient basis function evaluation</li>\n<li>Visualization available through Paraview (VTK) and Matplotlib</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>BSplineBasis</code>:  Class representing one-dimensional B-spline basis functions<br />\n<code>numpy.ndarray</code>:  Array type used for control points and evaluations<br />\n<code>scipy.sparse</code>:  Sparse matrix formats used for basis function evaluations  </p>\n"}, {"fullname": "bsplyne.b_spline.BSpline.__init__", "modulename": "bsplyne.b_spline", "qualname": "BSpline.__init__", "kind": "function", "doc": "<p>Initialize a <code>BSpline</code> instance with specified degrees and knot vectors.</p>\n\n<p>Creates a <code>BSpline</code> object by generating basis functions for each isoparametric dimension\nusing the provided polynomial degrees and knot vectors.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>degrees</strong> (Iterable[int]):\nCollection of polynomial degrees for each isoparametric dimension.\nThe length determines the dimensionality of the parametric space (<code>NPa</code>).\nFor example:\n<ul>\n<li>[p] for a curve</li>\n<li>[p, q] for a surface</li>\n<li>[p, q, r] for a volume</li>\n<li>...</li>\n</ul></li>\n<li><strong>knots</strong> (Iterable[np.ndarray[np.floating]]):\nCollection of knot vectors for each isoparametric dimension.\nEach knot vector must be a numpy array of <code>floats</code>.\nThe number of knot vectors must match the number of degrees.\nFor a degree <code>p</code>, the knot vector must have size <code>m + 1</code> where <code>m&gt;=p</code>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The number of control points in each dimension will be <code>m - p</code> where <code>m</code> is\nthe size of the knot vector minus 1 and <code>p</code> is the degree</li>\n<li>Each knot vector must be non-decreasing</li>\n<li>The multiplicity of each knot must not exceed <code>p + 1</code></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Create a 2D B-spline surface:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Create a 1D B-spline curve:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degree</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knot</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">curve</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degree</span><span class=\"p\">,</span> <span class=\"n\">knot</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">knots</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span></span>)</span>"}, {"fullname": "bsplyne.b_spline.BSpline.NPa", "modulename": "bsplyne.b_spline", "qualname": "BSpline.NPa", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.b_spline.BSpline.bases", "modulename": "bsplyne.b_spline", "qualname": "BSpline.bases", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray[bsplyne.b_spline_basis.BSplineBasis]"}, {"fullname": "bsplyne.b_spline.BSpline.from_bases", "modulename": "bsplyne.b_spline", "qualname": "BSpline.from_bases", "kind": "function", "doc": "<p>Create a BSpline instance from an array of <code>BSplineBasis</code> objects.\nThis is an alternative constructor that allows direct initialization from \nexisting basis functions rather than creating new ones from degrees and knot \nvectors.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bases</strong> (Iterable[BSplineBasis]):\nAn iterable (e.g. list, tuple, array) containing <code>BSplineBasis</code> instances.\nEach basis represents one parametric dimension of the resulting B-spline.\nThe number of bases determines the dimensionality of the parametric space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>BSpline</strong>: A new <code>BSpline</code> instance with the provided basis functions.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The method initializes a new <code>BSpline</code> instance with empty degrees and knots</li>\n<li>The bases array is populated with the provided <code>BSplineBasis</code> objects</li>\n<li>The dimensionality (<code>NPa</code>) is determined by the number of basis functions</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis1</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis2</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"o\">.</span><span class=\"n\">from_bases</span><span class=\"p\">([</span><span class=\"n\">basis1</span><span class=\"p\">,</span> <span class=\"n\">basis2</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">bases</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline_basis</span><span class=\"o\">.</span><span class=\"n\">BSplineBasis</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getDegrees", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getDegrees", "kind": "function", "doc": "<p>Returns the polynomial degree of each basis function in the isoparametric space.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>degrees</strong> (np.ndarray[np.integer]):\nArray containing the polynomial degrees of the B-spline basis functions.\nThe array has length <code>NPa</code> (dimension of isoparametric space), where each element\nrepresents the degree of the corresponding isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns [degree_xi]</li>\n<li>For a surface (2D), returns [degree_xi, degree_eta]</li>\n<li>For a volume (3D), returns [degree_xi, degree_eta, degree_zeta]</li>\n<li>...</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;int&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span> \n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getDegrees</span><span class=\"p\">()</span>\n<span class=\"go\">array([2, 2])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getKnots", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getKnots", "kind": "function", "doc": "<p>Returns the knot vector of each basis function in the isoparametric space.</p>\n\n<p>This method collects all knot vectors from each <code>BSplineBasis</code> instance stored\nin the <code>bases</code> array. The knot vectors define the isoparametric space partitioning\nand the regularity properties of the B-spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>knots</strong> (list[np.ndarray[np.floating]]):\nList containing the knot vectors of the B-spline basis functions.\nThe list has length <code>NPa</code> (dimension of isoparametric space), where each element\nis a <code>numpy.ndarray</code> containing the knots for the corresponding isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns [<code>knots_xi</code>]</li>\n<li>For a surface (2D), returns [<code>knots_xi</code>, <code>knots_eta</code>]</li>\n<li>For a volume (3D), returns [<code>knots_xi</code>, <code>knots_eta</code>, <code>knots_zeta</code>]</li>\n<li>Each knot vector must be non-decreasing</li>\n<li>The multiplicity of interior knots determines the continuity at that point</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getKnots</span><span class=\"p\">()</span>\n<span class=\"go\">[array([0., 0., 0., 0.5, 1., 1., 1.]),</span>\n<span class=\"go\"> array([0., 0., 0., 0.5, 1., 1., 1.])]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getCtrlShape", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getCtrlShape", "kind": "function", "doc": "<p>Get the shape of the control grid (number of control points per dimension).</p>\n\n<p>This method returns a tuple giving, for each isoparametric direction, \nthe number of control points associated with the corresponding B-spline basis. \nIn each dimension, this number is equal to <code>n + 1</code>, where <code>n</code> is the highest \nbasis function index.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple of int</strong>: A tuple giving the number of control points in each dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns a single integer (<code>n1 + 1</code>,)</li>\n<li>For a surface (2D), returns (<code>n1 + 1</code>, <code>n2 + 1</code>)</li>\n<li>For a volume (3D), returns (<code>n1 + 1</code>, <code>n2 + 1</code>, <code>n3 + 1</code>)</li>\n<li>The product of these values gives the total number of control points, \nidentical to the number of basis functions (<code>getNbFunc()</code>).</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getCtrlShape</span><span class=\"p\">()</span>\n<span class=\"go\">(4, 4)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getNbFunc", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getNbFunc", "kind": "function", "doc": "<p>Compute the total number of basis functions in the B-spline.</p>\n\n<p>This method calculates the total number of basis functions by multiplying\nthe number of basis functions in each isoparametric dimension (<code>n + 1</code> for each dimension).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Total number of basis functions in the B-spline. This is equal to\nthe product of (<code>n + 1</code>) for each basis, where <code>n</code> is the last index\nof each basis function.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns (<code>n + 1</code>)</li>\n<li>For a surface (2D), returns (<code>n1 + 1</code>) \u00d7 (<code>n2 + 1</code>)</li>\n<li>For a volume (3D), returns (<code>n1 + 1</code>) \u00d7 (<code>n2 + 1</code>) \u00d7 (<code>n3 + 1</code>)</li>\n<li>The number of basis functions equals the number of control points needed</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getNbFunc</span><span class=\"p\">()</span>\n<span class=\"go\">16</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getSpans", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getSpans", "kind": "function", "doc": "<p>Returns the span of each basis function in the isoparametric space.</p>\n\n<p>This method collects the spans (intervals of definition) from each <code>BSplineBasis</code>\ninstance stored in the <code>bases</code> array.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spans</strong> (list[tuple[float, float]]):\nList containing the spans of the B-spline basis functions.\nThe list has length <code>NPa</code> (dimension of isoparametric space), where each element\nis a tuple (<code>a</code>, <code>b</code>) containing the lower and upper bounds of the span\nfor the corresponding isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns [(<code>xi_min</code>, <code>xi_max</code>)]</li>\n<li>For a surface (2D), returns [(<code>xi_min</code>, <code>xi_max</code>), (<code>eta_min</code>, <code>eta_max</code>)]</li>\n<li>For a volume (3D), returns [(<code>xi_min</code>, <code>xi_max</code>), (<code>eta_min</code>, <code>eta_max</code>), (<code>zeta_min</code>, <code>zeta_max</code>)]</li>\n<li>The span represents the interval where the B-spline is defined</li>\n<li>Each span is determined by the <code>p</code>-th and <code>(m - p)</code>-th knots, where <code>p</code> is the degree\nand <code>m</code> is the last index of the knot vector</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getSpans</span><span class=\"p\">()</span>\n<span class=\"go\">[(0.0, 1.0), (0.0, 1.0)]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.linspace", "modulename": "bsplyne.b_spline", "qualname": "BSpline.linspace", "kind": "function", "doc": "<p>Generate sets of evaluation points over the span of each basis in the isoparametric space.</p>\n\n<p>This method creates evenly spaced points for each isoparametric dimension by calling\n<code>linspace</code> on each <code>BSplineBasis</code> instance stored in the <code>bases</code> array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nIf an <code>int</code> is provided, the same number is used for all dimensions.\nIf an <code>Iterable</code> is provided, each value corresponds to a different dimension.\nBy default, 10.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...]):\nTuple containing arrays of evaluation points for each isoparametric dimension.\nThe tuple has length <code>NPa</code> (dimension of isoparametric space).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns (<code>xi</code> points, )</li>\n<li>For a surface (2D), returns (<code>xi</code> points, <code>eta</code> points)</li>\n<li>For a volume (3D), returns (<code>xi</code> points, <code>eta</code> points, <code>zeta</code> points)</li>\n<li>The number of points returned for each dimension depends on the number of\nelements in that dimension times the value of <code>n_eval_per_elem</code></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">eta</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"n\">n_eval_per_elem</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span>\n<span class=\"go\">array([0.  , 0.25, 0.5 , 0.75, 1.  ])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eta</span>\n<span class=\"go\">array([0. , 0.5, 1. ])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.linspace_for_integration", "modulename": "bsplyne.b_spline", "qualname": "BSpline.linspace_for_integration", "kind": "function", "doc": "<p>Generate sets of evaluation points and their integration weights over each basis span.</p>\n\n<p>This method creates evenly spaced points and their corresponding integration weights\nfor each isoparametric dimension by calling <code>linspace_for_integration</code> on each\n<code>BSplineBasis</code> instance stored in the <code>bases</code> array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nIf an <code>int</code> is provided, the same number is used for all dimensions.\nIf an <code>Iterable</code> is provided, each value corresponds to a different dimension.\nBy default, 10.</li>\n<li><strong>bounding_box</strong> (Union[Iterable[tuple[float, float]], None], optional):\nLower and upper bounds for each isoparametric dimension.\nIf <code>None</code>, uses the span of each basis.\nFormat: [(<code>xi_min</code>, <code>xi_max</code>), (<code>eta_min</code>, <code>eta_max</code>), ...].\nBy default, None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...]):\nTuple containing arrays of evaluation points for each isoparametric dimension.\nThe tuple has length <code>NPa</code> (dimension of isoparametric space).</li>\n<li><strong>dXI</strong> (tuple[np.ndarray[np.floating], ...]):\nTuple containing arrays of integration weights for each isoparametric dimension.\nThe tuple has length <code>NPa</code> (dimension of isoparametric space).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns ((<code>xi</code> points), (<code>xi</code> weights))</li>\n<li>For a surface (2D), returns ((<code>xi</code> points, <code>eta</code> points), (<code>xi</code> weights, <code>eta</code> weights))</li>\n<li>For a volume (3D), returns ((<code>xi</code> points, <code>eta</code> points, <code>zeta</code> points), \n(<code>xi</code> weights, <code>eta</code> weights, <code>zeta</code> weights))</li>\n<li>The points are centered in their integration intervals</li>\n<li>The weights represent the size of the integration intervals</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">dxi</span><span class=\"p\">,</span> <span class=\"n\">deta</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">linspace_for_integration</span><span class=\"p\">(</span><span class=\"n\">n_eval_per_elem</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span>  <span class=\"c1\"># xi points</span>\n<span class=\"go\">array([0.125, 0.375, 0.625, 0.875])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dxi</span>  <span class=\"c1\"># xi weights</span>\n<span class=\"go\">array([0.25, 0.25, 0.25, 0.25])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">bounding_box</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.gauss_legendre_for_integration", "modulename": "bsplyne.b_spline", "qualname": "BSpline.gauss_legendre_for_integration", "kind": "function", "doc": "<p>Generate sets of evaluation points and their Gauss-Legendre integration weights over each basis span.</p>\n\n<p>This method creates Gauss-Legendre quadrature points and their corresponding integration weights\nfor each isoparametric dimension by calling <code>gauss_legendre_for_integration</code> on each\n<code>BSplineBasis</code> instance stored in the <code>bases</code> array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int], None], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nIf an <code>int</code> is provided, the same number is used for all dimensions.\nIf an <code>Iterable</code> is provided, each value corresponds to a different dimension.\nIf <code>None</code>, uses <code>p//2 + 1</code> points per element where <code>p</code> is the degree of each basis.\nThis number of points ensures an exact integration of a <code>p</code>-th degree polynomial.\nBy default, None.</li>\n<li><strong>bounding_box</strong> (Union[Iterable[tuple[float, float]], None], optional):\nLower and upper bounds for each isoparametric dimension.\nIf <code>None</code>, uses the span of each basis.\nFormat: [(<code>xi_min</code>, <code>xi_max</code>), (<code>eta_min</code>, <code>eta_max</code>), ...].\nBy default, None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...]):\nTuple containing arrays of Gauss-Legendre points for each isoparametric dimension.\nThe tuple has length <code>NPa</code> (dimension of isoparametric space).</li>\n<li><strong>dXI</strong> (tuple[np.ndarray[np.floating], ...]):\nTuple containing arrays of Gauss-Legendre weights for each isoparametric dimension.\nThe tuple has length <code>NPa</code> (dimension of isoparametric space).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns ((<code>xi</code> points), (<code>xi</code> weights))</li>\n<li>For a surface (2D), returns ((<code>xi</code> points, <code>eta</code> points), (<code>xi</code> weights, <code>eta</code> weights))</li>\n<li>For a volume (3D), returns ((<code>xi</code> points, <code>eta</code> points, <code>zeta</code> points), \n(<code>xi</code> weights, <code>eta</code> weights, <code>zeta</code> weights))</li>\n<li>The points and weights follow the Gauss-Legendre quadrature rule</li>\n<li>When <code>n_eval_per_elem</code> is <code>None</code>, uses <code>p//2 + 1</code> points per element for exact\nintegration of polynomials up to degree <code>p</code></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">dxi</span><span class=\"p\">,</span> <span class=\"n\">deta</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">gauss_legendre_for_integration</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span>  <span class=\"c1\"># 2 xi points per element =&gt; 4 points in total</span>\n<span class=\"go\">array([0.10566243, 0.39433757, 0.60566243, 0.89433757])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dxi</span>  <span class=\"c1\"># xi weights</span>\n<span class=\"go\">array([0.25, 0.25, 0.25, 0.25])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounding_box</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.normalize_knots", "modulename": "bsplyne.b_spline", "qualname": "BSpline.normalize_knots", "kind": "function", "doc": "<p>Maps all knot vectors to the interval [0, 1] in each isoparametric dimension.</p>\n\n<p>This method normalizes the knot vectors of each <code>BSplineBasis</code> instance stored\nin the <code>bases</code> array by applying an affine transformation that maps the span\ninterval to [0, 1].</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The transformation preserves the relative spacing between knots</li>\n<li>The transformation preserves the multiplicity of knots</li>\n<li>The transformation is applied independently to each isoparametric dimension</li>\n<li>This operation modifies the knot vectors in place</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getKnots</span><span class=\"p\">()</span>\n<span class=\"go\">[array([-1., -1., -1.,  0.,  1.,  1.,  1.]),</span>\n<span class=\"go\"> array([0., 0., 0., 2., 4., 4., 4.])]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">normalize_knots</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getKnots</span><span class=\"p\">()</span>\n<span class=\"go\">[array([0., 0., 0., 0.5, 1., 1., 1.]),</span>\n<span class=\"go\"> array([0., 0., 0., 0.5, 1., 1., 1.])]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.DN", "modulename": "bsplyne.b_spline", "qualname": "BSpline.DN", "kind": "function", "doc": "<p>Compute the <code>k</code>-th derivative of the B-spline basis at given points in the isoparametric space.</p>\n\n<p>This method evaluates the basis functions or their derivatives at specified points, returning\na matrix that can be used to evaluate the B-spline through a dot product with the control points.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>XI</strong> (Union[np.ndarray[np.floating], tuple[np.ndarray[np.floating], ...]]):\nPoints in the isoparametric space where to evaluate the basis functions.\nTwo input formats are accepted:\n<ol>\n<li><code>numpy.ndarray</code>: Array of coordinates with shape (<code>NPa</code>, n_points).\nEach column represents one evaluation point [<code>xi</code>, <code>eta</code>, ...].\nThe resulting matrices will have shape (n_points, number of functions).</li>\n<li><code>tuple</code>: Contains <code>NPa</code> arrays of coordinates (<code>xi</code>, <code>eta</code>, ...).\nThe resulting matrices will have (n_xi \u00d7 n_eta \u00d7 ...) rows.</li>\n</ol></li>\n<li><strong>k</strong> (Union[int, Iterable[int]], optional):\nDerivative orders to compute. Two formats are accepted:\n<ol>\n<li><code>int</code>: Same derivative order along all axes. Common values:</li>\n</ol>\n<ul>\n<li><code>k=0</code>: Evaluate basis functions (default)</li>\n<li><code>k=1</code>: Compute first derivatives (gradient)</li>\n<li><code>k=2</code>: Compute second derivatives (hessian)</li>\n</ul>\n<ol start=\"2\">\n<li><code>list[int]</code>: Different derivative orders for each axis.\nExample: <code>[1, 0]</code> computes first derivative w.r.t <code>xi</code>, no derivative w.r.t <code>eta</code>.\nBy default, 0.</li>\n</ol></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>DN</strong> (Union[sps.spmatrix, np.ndarray[sps.spmatrix]]):\nSparse matrix or array of sparse matrices containing the basis evaluations:\n<ul>\n<li>If <code>k</code> is a <code>list</code> or is 0: Returns a single sparse matrix containing the mixed \nderivative specified by the list.</li>\n<li>If <code>k</code> is an <code>int</code> &gt; 0: Returns an array of sparse matrices with shape [<code>NPa</code>]*<code>k</code>.\nFor example, if <code>k=1</code>, returns <code>NPa</code> matrices containing derivatives along each axis.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For evaluating the B-spline with control points in <code>NPh</code>-D space:\n<code>values = DN @ ctrl_pts.reshape((NPh, -1)).T</code></li>\n<li>When using tuple input format for <code>XI</code>, points are evaluated at all combinations of coordinates</li>\n<li>When using array input format for <code>XI</code>, each column represents one evaluation point</li>\n<li>The gradient (<code>k=1</code>) returns <code>NPa</code> matrices for derivatives along each axis</li>\n<li>Mixed derivatives can be computed using a list of derivative orders</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Create a 2D quadratic B-spline:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Evaluate basis functions at specific points using array input:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">XI</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>     <span class=\"c1\"># xi coordinates</span>\n<span class=\"gp\">... </span>               <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]])</span>    <span class=\"c1\"># eta coordinates</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">DN</span><span class=\"p\">(</span><span class=\"n\">XI</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">N</span><span class=\"o\">.</span><span class=\"n\">A</span>  <span class=\"c1\"># Convert sparse matrix to dense for display</span>\n<span class=\"go\">array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">      [0., 0., 0., 0., 0., 0.25, 0.25, 0., 0., 0.25, 0.25, 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">      [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]])</span>\n</code></pre>\n</div>\n\n<p>Compute first derivatives using tuple input:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dN</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">DN</span><span class=\"p\">((</span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># Returns [NPa] matrices</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">dN</span><span class=\"p\">)</span>  <span class=\"c1\"># Number of derivative matrices</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dN</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">A</span>  <span class=\"c1\"># Derivative w.r.t xi</span>\n<span class=\"go\">array([[-4., 0., 0., 0., 4., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0., 0.,-4., 0., 0., 0., 4., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0., 0., 0.,-2., 0., 0., 0., 2., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0., 0., 0., 0., 0., 0.,-2., 0., 0., 0., 2., 0., 0., 0., 0.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dN</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">A</span>  <span class=\"c1\"># Derivative w.r.t eta</span>\n<span class=\"go\">array([[-4., 4., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0.,-4., 4., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0., 0., 0.,-2., 2., 0., 0.,-2., 2., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0., 0., 0., 0., 0., 0.,-2., 2., 0., 0.,-2., 2., 0., 0., 0., 0.]])</span>\n</code></pre>\n</div>\n\n<p>Compute mixed derivatives:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d2N</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">DN</span><span class=\"p\">((</span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">eta</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>  <span class=\"c1\"># Second derivative: d\u00b2/dxi\u00b7deta</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d2N</span><span class=\"o\">.</span><span class=\"n\">A</span>\n<span class=\"go\">array([[16.,-16.,  0.,  0.,-16.,16.,  0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0.,  0., 16.,-16.,  0., 0.,-16.,16., 0., 0., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0.,  0.,  0.,  0.,  8.,-8.,  0., 0.,-8., 8., 0., 0., 0., 0., 0., 0.],</span>\n<span class=\"go\">       [ 0.,  0.,  0.,  0.,  0., 0.,  8.,-8., 0.,-0.,-8., 8., 0., 0., 0., 0.]])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_matrix</span><span class=\"o\">.</span><span class=\"n\">spmatrix</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_matrix</span><span class=\"o\">.</span><span class=\"n\">spmatrix</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.knotInsertion", "modulename": "bsplyne.b_spline", "qualname": "BSpline.knotInsertion", "kind": "function", "doc": "<p>Add knots to the B-spline while preserving its geometry.</p>\n\n<p>This method performs knot insertion by adding new knots to each isoparametric dimension\nand computing the new control points to maintain the exact same geometry. The method\nmodifies the <code>BSpline</code> object by updating its basis functions with the new knots.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nControl points defining the B-spline geometry.\nShape: (<code>NPh</code>, n1, n2, ...) where:\n<ul>\n<li><code>NPh</code> is the dimension of the physical space</li>\n<li>ni is the number of control points in the i-th isoparametric dimension\nIf None is passed, the knot insertion is performed on the basis functions \nbut not on the control points.</li>\n</ul></li>\n<li><strong>knots_to_add</strong> (Iterable[Union[np.ndarray[np.floating], int]]):\nRefinement specification for each isoparametric dimension.\nFor each dimension, two formats are accepted:\n<ol>\n<li><code>numpy.ndarray</code>: Array of knots to insert. These knots must lie within\nthe span of the existing knot vector.</li>\n<li><code>int</code>: Number of equally spaced knots to insert in each element.</li>\n</ol></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>new_ctrl_pts</strong> (np.ndarray[np.floating]):\nNew control points after knot insertion.\nShape: (<code>NPh</code>, m1, m2, ...) where mi \u2265 ni is the new number of\ncontrol points in the i-th isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Knot insertion preserves the geometry and parameterization of the B-spline</li>\n<li>The number of new control points depends on the number and multiplicity of inserted knots</li>\n<li>When using integer input, knots are inserted with uniform spacing in each element</li>\n<li>The method modifies the basis functions but maintains <code>C^{p-m}</code> continuity,\nwhere <code>p</code> is the degree and <code>m</code> is the multiplicity of the inserted knot</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Create a 2D quadratic B-spline and insert knots:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n</code></pre>\n</div>\n\n<p>Insert specific knots in first dimension only:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots_to_add</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.75</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>                <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">knotInsertion</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">,</span> <span class=\"n\">knots_to_add</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(3, 6, 4)  # Two new control points added in first dimension</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getKnots</span><span class=\"p\">()[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># The knot vector is modified</span>\n<span class=\"go\">array([0.  , 0.  , 0.  , 0.25, 0.5 , 0.75, 1.  , 1.  , 1.  ])</span>\n</code></pre>\n</div>\n\n<p>Insert two knots per element in both dimensions:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">knotInsertion</span><span class=\"p\">(</span><span class=\"n\">new_ctrl_pts</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(3, 10, 6)  # Uniform refinement in both dimensions</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getKnots</span><span class=\"p\">()[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># The knot vectors are further modified</span>\n<span class=\"go\">array([0.   , 0.   , 0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 ,</span>\n<span class=\"go\">       0.875, 1.   , 1.   , 1.   ])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">knots_to_add</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.orderElevation", "modulename": "bsplyne.b_spline", "qualname": "BSpline.orderElevation", "kind": "function", "doc": "<p>Elevate the polynomial degree of the B-spline while preserving its geometry.</p>\n\n<p>This method performs order elevation by increasing the polynomial degree of each\nisoparametric dimension and computing the new control points to maintain the exact\nsame geometry. The method modifies the <code>BSpline</code> object by updating its basis\nfunctions with the new degrees.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (Union[np.ndarray[np.floating], None]):\nControl points defining the B-spline geometry.\nShape: (<code>NPh</code>, n1, n2, ...) where:\n<ul>\n<li><code>NPh</code> is the dimension of the physical space</li>\n<li>ni is the number of control points in the i-th isoparametric dimension\nIf None is passed, the order elevation is performed on the basis functions \nbut not on the control points.</li>\n</ul></li>\n<li><strong>t</strong> (Iterable[int]):\nDegree elevation for each isoparametric dimension.\nFor each dimension i, the new degree will be <code>p_i + t_i</code> where <code>p_i</code>\nis the current degree.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>new_ctrl_pts</strong> (np.ndarray[np.floating]):\nNew control points after order elevation.\nShape: (<code>NPh</code>, m1, m2, ...) where mi \u2265 ni is the new number of\ncontrol points in the i-th isoparametric dimension.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Order elevation preserves the geometry and parameterization of the B-spline</li>\n<li>The number of new control points depends on the current degree and number of \nelements</li>\n<li>The method modifies the <code>BSpline</code> object by updating its basis functions</li>\n<li>This operation is more computationally expensive than knot insertion</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Create a 2D quadratic B-spline and elevate its order:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n</code></pre>\n</div>\n\n<p>Elevate order by 1 in first dimension only:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># Increase degree by 1 in first dimension</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">orderElevation</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_ctrl_pts</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(3, 6, 4)  # Two new control points added in first dimension (one per element)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">getDegrees</span><span class=\"p\">()</span>  <span class=\"c1\"># The degrees are modified</span>\n<span class=\"go\">array([3, 2])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.greville_abscissa", "modulename": "bsplyne.b_spline", "qualname": "BSpline.greville_abscissa", "kind": "function", "doc": "<p>Compute the Greville abscissa and optionally their weights for each isoparametric dimension.</p>\n\n<p>The Greville abscissa can be interpreted as the \"position\" of the control points in the \nisoparametric space. They are often used as interpolation points for B-splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>return_weights</strong> (bool, optional):\nIf <code>True</code>, also returns the weights (span lengths) of each basis function.\nBy default, False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>greville</strong> (list[np.ndarray[np.floating]]):\nList containing the Greville abscissa for each isoparametric dimension.\nThe list has length <code>NPa</code>, where each element is an array of size <code>n + 1</code>,\n<code>n</code> being the last index of the basis functions in that dimension.</li>\n<li><strong>weights</strong> (list[np.ndarray[np.floating]], optional):\nOnly returned if <code>return_weights</code> is <code>True</code>.\nList containing the weights for each isoparametric dimension.\nThe list has length <code>NPa</code>, where each element is an array containing\nthe span length of each basis function.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For a curve (1D), returns [<code>xi</code> abscissa]</li>\n<li>For a surface (2D), returns [<code>xi</code> abscissa, <code>eta</code> abscissa]</li>\n<li>For a volume (3D), returns [<code>xi</code> abscissa, <code>eta</code> abscissa, <code>zeta</code> abscissa]</li>\n<li>The Greville abscissa are computed as averages of <code>p</code> consecutive knots</li>\n<li>The weights represent the size of the support of each basis function</li>\n<li>The number of abscissa in each dimension equals the number of control points</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Compute Greville abscissa for a 2D B-spline:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">greville_abscissa</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># xi coordinates</span>\n<span class=\"go\">array([0.  , 0.25, 0.75, 1.  ])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>  <span class=\"c1\"># eta coordinates</span>\n<span class=\"go\">array([0. , 0.5, 1. ])</span>\n</code></pre>\n</div>\n\n<p>Compute both abscissa and weights:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span><span class=\"p\">,</span> <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">greville_abscissa</span><span class=\"p\">(</span><span class=\"n\">return_weights</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">weights</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># weights for xi direction</span>\n<span class=\"go\">array([0.5, 1. , 1. , 0.5])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">return_weights</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.make_control_poly_meshes", "modulename": "bsplyne.b_spline", "qualname": "BSpline.make_control_poly_meshes", "kind": "function", "doc": "<p>Create meshes containing all the data needed to plot the control polygon of the B-spline.</p>\n\n<p>This method generates a list of <code>io.Mesh</code> objects representing the control mesh \n(polygonal connectivity) of the B-spline, suitable for visualization (e.g. in Paraview). \nIt supports time-dependent fields and arbitrary dimension.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nArray of control points of the B-spline, with shape \n(<code>NPh</code>, number of elements for dim 1, ..., number of elements for dim <code>NPa</code>), \nwhere <code>NPh</code> is the physical space dimension and <code>NPa</code> is the dimension of the \nisoparametric space.</li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to plot. By default, 1.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nBy default, 10.\n<ul>\n<li>If an <code>int</code> is provided, the same number is used for all dimensions.</li>\n<li>If an <code>Iterable</code> is provided, each value corresponds to a different dimension.</li>\n</ul></li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to plot. By default, 1.</li>\n<li><strong>fields</strong> (dict, optional):\nDictionary of fields to plot at each time step. Keys are field names. Values can be:\n<ul>\n<li>a <code>function</code> taking (<code>BSpline</code> spline, <code>tuple</code> of <code>np.ndarray[np.floating]</code> XI) and\nreturning a <code>np.ndarray[np.floating]</code> of shape (<code>n_step</code>, number of combinations of XI, field size),</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>on the control points</strong>, of shape (<code>n_step</code>, field size, *<code>ctrl_pts.shape[1:]</code>),\nwhich is then interpolated using the B-spline basis functions,</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>on the evaluation grid</strong>, of shape (<code>n_step</code>, field size, *grid shape),\nwhere <code>grid shape</code> matches the discretization provided by XI or <code>n_eval_per_elem</code>.\nIn this case, the field is interpolated in physical space using <code>scipy.interpolate.griddata</code>.</li>\n</ul></li>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...], optional):\nParametric coordinates at which to evaluate the B-spline and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, a regular grid is generated according to <code>n_eval_per_elem</code>.</li>\n<li><strong>paraview_sizes</strong> (dict, optionnal):\nThe fields present in this <code>dict</code> are overrided by <code>np.NaN</code>s.\nThe keys must be the fields names and the values must be the fields sizes for paraview.\nBy default, {}.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list[io.Mesh]</strong>: List of <code>io.Mesh</code> objects, one for each time step, containing the control mesh geometry \nand associated fields.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The control mesh is constructed by connecting control points along each isoparametric direction.</li>\n<li>Fields can be provided either as functions evaluated at the Greville abscissae, or as arrays defined on the \ncontrol points or on a regular parametric grid (in which case they are interpolated at the Greville abscissae).</li>\n<li>The first axis of the field array or function output corresponds to the time step, even if there is only one.</li>\n<li>The method is compatible with B-splines of arbitrary dimension.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points for a 2D surface</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">meshes</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">make_control_poly_meshes</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">meshes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paraview_sizes</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.make_elem_separator_meshes", "modulename": "bsplyne.b_spline", "qualname": "BSpline.make_elem_separator_meshes", "kind": "function", "doc": "<p>Create meshes representing the boundaries of every element in the B-spline for visualization.</p>\n\n<p>This method generates a list of <code>io.Mesh</code> objects containing the geometry and optional fields\nneeded to plot the limits (borders) of all elements from the isoparametric space of the B-spline.\nSupports time-dependent fields and arbitrary dimension.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nArray of control points of the B-spline, with shape\n(<code>NPh</code>, number of elements for dim 1, ..., number of elements for dim <code>NPa</code>),\nwhere <code>NPh</code> is the physical space dimension and <code>NPa</code> is the dimension of the\nisoparametric space.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nBy default, 10.\n<ul>\n<li>If an <code>int</code> is provided, the same number is used for all dimensions.</li>\n<li>If an <code>Iterable</code> is provided, each value corresponds to a different dimension.</li>\n</ul></li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to plot. By default, 1.</li>\n<li><strong>fields</strong> (dict, optional):\nDictionary of fields to plot at each time step. Keys are field names. Values can be:\n<ul>\n<li>a <code>function</code> taking (<code>BSpline</code> spline, <code>tuple</code> of <code>np.ndarray[np.floating]</code> XI) and\nreturning a <code>np.ndarray[np.floating]</code> of shape (<code>n_step</code>, number of combinations of XI, field size),</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>on the control points</strong>, of shape (<code>n_step</code>, field size, *<code>ctrl_pts.shape[1:]</code>),\nwhich is then interpolated using the B-spline basis functions,</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>on the evaluation grid</strong>, of shape (<code>n_step</code>, field size, *grid shape),\nwhere <code>grid shape</code> matches the discretization provided by XI or <code>n_eval_per_elem</code>.\nIn this case, the field is interpolated in physical space using <code>scipy.interpolate.griddata</code>.</li>\n</ul></li>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...], optional):\nParametric coordinates at which to evaluate the B-spline and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, a regular grid is generated according to <code>n_eval_per_elem</code>.</li>\n<li><strong>paraview_sizes</strong> (dict, optionnal):\nThe fields present in this <code>dict</code> are overrided by <code>np.NaN</code>s.\nThe keys must be the fields names and the values must be the fields sizes for paraview.\nBy default, {}.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list[io.Mesh]</strong>: List of <code>io.Mesh</code> objects, one for each time step, containing the element boundary geometry\nand associated fields.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The element boundary mesh is constructed by connecting points along the unique knot values\nin each isoparametric direction, outlining the limits of each element.</li>\n<li>Fields can be provided either as callable functions, as arrays defined on the control points,\nor as arrays already defined on a regular evaluation grid.</li>\n<li>When fields are defined on a grid, they are interpolated in the physical space using\n<code>scipy.interpolate.griddata</code> with linear interpolation.</li>\n<li>The first axis of the field array or function output corresponds to the time step, even if there is only one.</li>\n<li>The method supports B-splines of arbitrary dimension.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points for a 2D surface</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">meshes</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">make_elem_separator_meshes</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">meshes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paraview_sizes</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.make_elements_interior_meshes", "modulename": "bsplyne.b_spline", "qualname": "BSpline.make_elements_interior_meshes", "kind": "function", "doc": "<p>Create meshes representing the interior of each element in the B-spline.</p>\n\n<p>This method generates a list of <code>io.Mesh</code> objects containing the geometry and optional fields\nfor the interior of all elements, suitable for visualization (e.g., in ParaView). Supports\ntime-dependent fields and arbitrary dimension.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nArray of control points of the B-spline, with shape\n(<code>NPh</code>, number of points for dim 1, ..., number of points for dim <code>NPa</code>),\nwhere <code>NPh</code> is the physical space dimension and <code>NPa</code> is the dimension of\nthe isoparametric space.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nBy default, 10.\n<ul>\n<li>If an <code>int</code> is provided, the same number is used for all dimensions.</li>\n<li>If an <code>Iterable</code> is provided, each value corresponds to a different dimension.</li>\n</ul></li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to plot. By default, 1.</li>\n<li><strong>fields</strong> (dict, optional):\nDictionary of fields to plot at each time step. Keys are field names. Values can be:\n<ul>\n<li>a <code>function</code> taking (<code>BSpline</code> spline, <code>tuple</code> of <code>np.ndarray[np.floating]</code> XI) and\nreturning a <code>np.ndarray[np.floating]</code> of shape (<code>n_step</code>, number of combinations of XI, field size),</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>on the control points</strong>, of shape (<code>n_step</code>, field size, *<code>ctrl_pts.shape[1:]</code>),\nin which case it is interpolated using the B-spline basis functions,</li>\n<li>a <code>np.ndarray[np.floating]</code> defined <strong>directly on the evaluation grid</strong>, of shape (<code>n_step</code>, field size, *grid shape),\nwhere <code>grid shape</code> is the shape of the discretization XI (i.e., number of points along each parametric axis).\nBy default, <code>{}</code> (no fields).</li>\n</ul></li>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...], optional):\nParametric coordinates at which to evaluate the B-spline and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, a regular grid is generated according to <code>n_eval_per_elem</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list[io.Mesh]</strong>: List of <code>io.Mesh</code> objects, one for each time step, containing the element interior geometry\nand associated fields.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The interior mesh is constructed by evaluating the B-spline at a regular grid of points\nin the isoparametric space, with connectivity corresponding to lines (1D), quads (2D), or\nhexahedra (3D).</li>\n<li>Fields can be provided either as arrays (on control points or on the discretization grid) or as functions.</li>\n<li>Arrays given on control points are automatically interpolated using the B-spline basis functions.</li>\n<li>Arrays already given on the evaluation grid are used directly without interpolation.</li>\n<li>The first axis of the field array or function output must correspond to the time step, even if there is only one.</li>\n<li>The method is compatible with B-splines of arbitrary dimension.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points for a 2D surface</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Field given on control points (needs interpolation)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">field_on_ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Field given directly on the evaluation grid (no interpolation)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">field_on_grid</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">meshes</span> <span class=\"o\">=</span> <span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">make_elements_interior_meshes</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">ctrl_pts</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">fields</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;temperature&#39;</span><span class=\"p\">:</span> <span class=\"n\">field_on_ctrl_pts</span><span class=\"p\">,</span> <span class=\"s1\">&#39;pressure&#39;</span><span class=\"p\">:</span> <span class=\"n\">field_on_grid</span><span class=\"p\">}</span>\n<span class=\"gp\">... </span>    <span class=\"n\">XI</span><span class=\"o\">=</span> <span class=\"c1\"># TODO</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">meshes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.saveParaview", "modulename": "bsplyne.b_spline", "qualname": "BSpline.saveParaview", "kind": "function", "doc": "<p>Save B-spline visualization data as Paraview files.</p>\n\n<p>This method creates three types of visualization files:</p>\n\n<ul>\n<li>Interior mesh showing the B-spline surface/volume</li>\n<li>Element borders showing the mesh structure</li>\n<li>Control points mesh showing the control structure</li>\n</ul>\n\n<p>All files are saved in VTU format with an optional PVD file to group them.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nControl points defining the B-spline geometry.\nShape: (<code>NPh</code>, n1, n2, ...) where:\n<ul>\n<li><code>NPh</code> is the dimension of the physical space</li>\n<li>ni is the number of control points in the i-th isoparametric dimension</li>\n</ul></li>\n<li><strong>path</strong> (str):\nDirectory path where the PV files will be saved</li>\n<li><strong>name</strong> (str):\nBase name for the output files</li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to save. By default, 1.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nBy default, 10.\n<ul>\n<li>If an <code>int</code> is provided, the same number is used for all dimensions.</li>\n<li>If an <code>Iterable</code> is provided, each value corresponds to a different dimension.</li>\n</ul></li>\n<li><p><strong>fields</strong> (Union[dict, None], optional):\nFields to visualize at each time step. Dictionary format:\n{\n    \"field_name\": <code>field_value</code>\n}\nwhere <code>field_value</code> can be either:</p>\n\n<ol>\n<li>A numpy array with shape (<code>n_step</code>, <code>field_size</code>, <code>*ctrl_pts.shape[1:]</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n<li><code>*ctrl_pts.shape[1:]</code>: Same shape as control points (excluding <code>NPh</code>)</li>\n</ul>\n\n<ol start=\"2\">\n<li>A numpy array with shape (<code>n_step</code>, <code>field_size</code>, <code>*grid_shape</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n<li><code>*grid_shape</code>: Shape of the evaluation grid (number of points along each isoparametric axis)</li>\n</ul>\n\n<ol start=\"3\">\n<li>A function that computes field values (<code>np.ndarray[np.floating]</code>) at given \npoints from the <code>BSpline</code> instance and <code>XI</code>, the tuple of arrays containing evaluation \npoints for each dimension (<code>tuple[np.ndarray[np.floating], ...]</code>).\nThe result should be an array of shape (<code>n_step</code>, <code>n_points</code>, <code>field_size</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>n_points</code>: Number of evaluation points (n_xi \u00d7 n_eta \u00d7 ...)</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n</ul>\n\n<p>By default, None.</p></li>\n<li><strong>XI</strong> (tuple[np.ndarray[np.floating], ...], optional):\nParametric coordinates at which to evaluate the B-spline and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, a regular grid is generated according to <code>n_eval_per_elem</code>.</li>\n<li><p><strong>groups</strong> (Union[dict[str, dict[str, Union[str, int]]], None], optional):\nNested dictionary specifying file groups for PVD organization. Format:\n{\n    \"group_name\": {\n        \"ext\": str,     # File extension (e.g., \"vtu\")\n        \"npart\": int,   # Number of parts in the group\n        \"nstep\": int    # Number of timesteps\n    }\n}\nThe method automatically creates/updates three groups:</p>\n\n<ul>\n<li>\"interior\": For the B-spline surface/volume mesh</li>\n<li>\"elements_borders\": For the element boundary mesh</li>\n<li>\"control_points\": For the control point mesh</li>\n</ul>\n\n<p>If provided, existing groups are updated; if None, these groups are created.\nBy default, None.</p></li>\n<li><strong>make_pvd</strong> (bool, optional):\nWhether to create a PVD file grouping all VTU files. By default, True.</li>\n<li><strong>verbose</strong> (bool, optional):\nWhether to print progress information. By default, True.</li>\n<li><strong>fields_on_interior_only</strong> (Union[bool, Literal['auto'], list[str]], optionnal):\nWhether to include fields only on the interior mesh (<code>True</code>), on all meshes (<code>False</code>),\nor on specified field names.\nIf set to <code>'auto'</code>, fields named <code>'u'</code>, <code>'U'</code>, <code>'displacement'</code> or <code>'displ'</code> \nare included on all meshes while others are only included on the interior mesh.\nBy default, 'auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>groups</strong> (dict[str, dict[str, Union[str, int]]]):\nUpdated groups dictionary with information about saved files.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Creates three types of VTU files for each time step:\n<ul>\n<li>{name}_interior_{part}_{step}.vtu</li>\n<li>{name}_elements_borders_{part}_{step}.vtu</li>\n<li>{name}_control_points_{part}_{step}.vtu</li>\n</ul></li>\n<li>If <code>make_pvd=True</code>, creates a PVD file named {name}.pvd</li>\n<li>Fields can be visualized as scalars or vectors in Paraview</li>\n<li>The method supports time-dependent visualization through <code>n_step</code></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Save a 2D B-spline visualization:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">saveParaview</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">,</span> <span class=\"s2\">&quot;./output&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;bspline&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Save with a custom field:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">displacement</span><span class=\"p\">(</span><span class=\"n\">spline</span><span class=\"p\">,</span> <span class=\"n\">XI</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Compute displacement field</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">prod</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">XI</span><span class=\"p\">]),</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">&quot;displacement&quot;</span><span class=\"p\">:</span> <span class=\"n\">displacement</span><span class=\"p\">}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">saveParaview</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">,</span> <span class=\"s2\">&quot;./output&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;bspline&quot;</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"o\">=</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groups</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">make_pvd</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">fields_on_interior_only</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.getGeomdl", "modulename": "bsplyne.b_spline", "qualname": "BSpline.getGeomdl", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ctrl_pts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.to_dict", "modulename": "bsplyne.b_spline", "qualname": "BSpline.to_dict", "kind": "function", "doc": "<p>Returns a dictionary representation of the BSpline object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.from_dict", "modulename": "bsplyne.b_spline", "qualname": "BSpline.from_dict", "kind": "function", "doc": "<p>Creates a BSpline object from a dictionary representation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.save", "modulename": "bsplyne.b_spline", "qualname": "BSpline.save", "kind": "function", "doc": "<p>Save the BSpline object to a file.\nControl points are optional.\nSupported extensions: json, pkl</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.load", "modulename": "bsplyne.b_spline", "qualname": "BSpline.load", "kind": "function", "doc": "<p>Load a BSpline object from a file.\nMay return control points if the file contains them.\nSupported extensions: json, pkl</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.plot", "modulename": "bsplyne.b_spline", "qualname": "BSpline.plot", "kind": "function", "doc": "<p>Plot the B-spline using either Matplotlib or PyVista, depending on availability.</p>\n\n<p>Automatically selects the appropriate plotting backend (Matplotlib or PyVista)\nbased on which libraries are installed. Supports visualization of B-spline curves,\nsurfaces, and volumes in 2D or 3D space, with control mesh, element borders, and patch borders.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nControl points defining the B-spline geometry.\nShape: (NPh, n1, n2, ...) where:\n<ul>\n<li>NPh is the dimension of the physical space (2 or 3)</li>\n<li>ni is the number of control points in the i-th isoparametric dimension</li>\n</ul></li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for visualizing the B-spline.\nCan be specified as:\n<ul>\n<li>Single integer: Same number for all dimensions</li>\n<li>Iterable of integers: Different numbers for each dimension\nBy default, 10.</li>\n</ul></li>\n<li><strong>plotter</strong> (Union[mpl.axes.Axes, 'pv.Plotter', None], optional):\nPlotter object for the visualization:\n<ul>\n<li>If PyVista is available: Can be a <code>pv.Plotter</code> instance</li>\n<li>If only Matplotlib is available: Can be a <code>mpl.axes.Axes</code> instance</li>\n<li>If None, creates a new plotter/axes.\nDefault is None.</li>\n</ul></li>\n<li><strong>ctrl_color</strong> (str, optional):\nColor for the control mesh visualization.\nDefault is '#d95f02' (orange).</li>\n<li><strong>interior_color</strong> (str, optional):\nColor for the B-spline geometry.\nDefault is '#666666' (gray).</li>\n<li><strong>elem_color</strong> (str, optional):\nColor for element boundary visualization.\nDefault is '#7570b3' (purple).</li>\n<li><strong>border_color</strong> (str, optional):\nColor for patch boundary visualization.\nDefault is '#1b9e77' (green).</li>\n<li><strong>language</strong> (str, optional):\nLanguage for the plot labels and legends in matplotlib. Can be 'english' or 'fran\u00e7ais'.\nDefault is 'english'.</li>\n<li><strong>show</strong> (bool, optional):\nWhether to display the plot immediately.\nDefault is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>plotter</strong> (Union[mpl.axes.Axes, 'pv.Plotter', None]):\nThe plotter object used for visualization (Matplotlib axes or PyVista plotter)\nif <code>show</code> is False. Otherwise, returns None.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>If PyVista is available and the physical space is 3D, uses <code>plotPV</code> for 3D visualization.</li>\n<li>Otherwise, uses <code>plotMPL</code> for 2D/3D visualization with Matplotlib.</li>\n<li>For 3D visualization, PyVista is recommended for better interactivity and rendering.</li>\n<li>For 2D visualization, Matplotlib is used by default.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Plot a 2D curve in 2D space:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 2D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Plot a 2D surface in 3D space with PyVista (if available):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">plotter</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"s1\">&#39;pv.Plotter&#39;</span><span class=\"p\">),</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#d95f02&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">interior_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#666666&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">elem_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#7570b3&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">border_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#1b9e77&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;english&#39;</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;fran\u00e7ais&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;english&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"s1\">&#39;pv.Plotter&#39;</span><span class=\"p\">),</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.plotMPL", "modulename": "bsplyne.b_spline", "qualname": "BSpline.plotMPL", "kind": "function", "doc": "<p>Plot the B-spline using Matplotlib.</p>\n\n<p>Creates a visualization of the B-spline geometry showing the control mesh,\nB-spline surface/curve, element borders, and patch borders. Supports plotting\n1D curves and 2D surfaces in 2D space, and 2D surfaces and 3D volumes in 3D space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nControl points defining the B-spline geometry.\nShape: (NPh, n1, n2, ...) where:\n<ul>\n<li>NPh is the dimension of the physical space (2 or 3)</li>\n<li>ni is the number of control points in the i-th isoparametric dimension</li>\n</ul></li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for visualizing the B-spline.\nCan be specified as:\n<ul>\n<li>Single integer: Same number for all dimensions</li>\n<li>Iterable of integers: Different numbers for each dimension\nBy default, 10.</li>\n</ul></li>\n<li><strong>ax</strong> (Union[mpl.axes.Axes, None], optional):\nMatplotlib axes for plotting. If None, creates a new figure and axes.\nFor 3D visualizations, must be a 3D axes if provided (created with \n<code>projection='3d'</code>).\nDefault is None (creates new axes).</li>\n<li><strong>ctrl_color</strong> (str, optional):\nColor for the control mesh visualization:\n<ul>\n<li>Applied to control points (markers)</li>\n<li>Applied to control mesh lines\nDefault is '#1b9e77' (green).</li>\n</ul></li>\n<li><strong>interior_color</strong> (str, optional):\nColor for the B-spline geometry:\n<ul>\n<li>For curves: Line color</li>\n<li>For surfaces: Face color (with transparency)</li>\n<li>For volumes: Face color of boundary surfaces (with transparency)\nDefault is '#7570b3' (purple).</li>\n</ul></li>\n<li><strong>elem_color</strong> (str, optional):\nColor for element boundary visualization:\n<ul>\n<li>Shows internal mesh structure</li>\n<li>Helps visualize knot locations\nDefault is '#666666' (gray).</li>\n</ul></li>\n<li><strong>border_color</strong> (str, optional):\nColor for patch boundary visualization:\n<ul>\n<li>Outlines the entire B-spline patch</li>\n<li>Helps distinguish patch edges\nDefault is '#d95f02' (orange).</li>\n</ul></li>\n<li><strong>language</strong> (str, optional):\nLanguage for the plot labels. Can be 'english' or 'fran\u00e7ais'.\nDefault is 'english'.</li>\n<li><strong>show</strong> (bool, optional):\nWhether to display the plot immediately. Can be useful to add more stuff to the plot.\nDefault is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ax</strong> (Union[mpl.axes.Axes, None]):\nMatplotlib axes for the plot if show is deactivated, otherwise None.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Visualization components:</p>\n\n<ul>\n<li>Control mesh: Shows control points and their connections</li>\n<li>B-spline: Shows the actual curve/surface/volume</li>\n<li>Element borders: Shows the boundaries between elements</li>\n<li>Patch borders: Shows the outer boundaries of the B-spline</li>\n</ul>\n\n<p>Supported configurations:</p>\n\n<ul>\n<li>1D B-spline in 2D space (curve)</li>\n<li>2D B-spline in 2D space (surface)</li>\n<li>2D B-spline in 3D space (surface)</li>\n<li>3D B-spline in 3D space (volume)</li>\n</ul>\n\n<p>For 3D visualization:</p>\n\n<ul>\n<li>Surfaces are shown with transparency</li>\n<li>Volume visualization shows the faces with transparency</li>\n<li>View angle is automatically set for surfaces based on surface normal</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Plot a 2D curve in 2D space:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 2D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plotMPL</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Plot a 2D surface in 3D space:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plotMPL</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Plot on existing axes with custom colors:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fig</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">fig</span><span class=\"o\">.</span><span class=\"n\">add_subplot</span><span class=\"p\">(</span><span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"s1\">&#39;3d&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plotMPL</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">,</span> <span class=\"n\">ctrl_color</span><span class=\"o\">=</span><span class=\"s1\">&#39;red&#39;</span><span class=\"p\">,</span> <span class=\"n\">interior_color</span><span class=\"o\">=</span><span class=\"s1\">&#39;blue&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#1b9e77&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">interior_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#7570b3&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">elem_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#666666&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">border_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#d95f02&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;english&#39;</span><span class=\"p\">],</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;fran\u00e7ais&#39;</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;english&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline.BSpline.plotPV", "modulename": "bsplyne.b_spline", "qualname": "BSpline.plotPV", "kind": "function", "doc": "<p>Plot the B-spline using PyVista for 3D visualization.</p>\n\n<p>Creates an interactive 3D visualization of the B-spline geometry showing the control mesh,\nB-spline surface/curve/volume, element borders, and patch borders. Supports plotting\n1D curves, 2D surfaces, and 3D volumes in 3D space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ctrl_pts</strong> (np.ndarray[np.floating]):\nControl points defining the B-spline geometry.\nShape: (NPh, n1, n2, ...) where:\n<ul>\n<li>NPh is the dimension of the physical space (2 or 3)</li>\n<li>ni is the number of control points in the i-th isoparametric dimension\nIf NPh=2, control points are automatically converted to 3D for plotting.</li>\n</ul></li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for visualizing the B-spline.\nCan be specified as:\n<ul>\n<li>Single integer: Same number for all dimensions</li>\n<li>Iterable of integers: Different numbers for each dimension\nBy default, 10.</li>\n</ul></li>\n<li><strong>pv_plotter</strong> (Union['pv.Plotter', None], optional):\nPyVista plotter for visualization. If None, creates a new plotter.\nDefault is None.</li>\n<li><strong>ctrl_color</strong> (str, optional):\nColor for the control mesh visualization.\nDefault is '#d95f02' (orange).</li>\n<li><strong>interior_color</strong> (str, optional):\nColor for the B-spline geometry.\nDefault is '#666666' (gray).</li>\n<li><strong>elem_color</strong> (str, optional):\nColor for element boundary visualization.\nDefault is '#7570b3' (purple).</li>\n<li><strong>border_color</strong> (str, optional):\nColor for patch boundary visualization.\nDefault is '#1b9e77' (green).</li>\n<li><strong>show</strong> (bool, optional):\nWhether to display the plot immediately.\nDefault is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pv_plotter</strong> (Union['pv.Plotter', None]):\nThe PyVista plotter object used for visualization if show is False.\nOtherwise, returns None.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For 1D B-splines: Plots the curve and control points.</li>\n<li>For 2D B-splines: Plots the surface, control points, element borders, and patch borders.</li>\n<li>For 3D B-splines: Plots the volume faces, control points, element borders, and patch borders.</li>\n<li>If control points are 2D, they are automatically converted to 3D with z=0 for plotting.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Plot a curved line in 3D space:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plotPV</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Plot a 2D surface in 3D space:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degrees</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knots</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>         <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span> <span class=\"o\">=</span> <span class=\"n\">BSpline</span><span class=\"p\">(</span><span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">knots</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ctrl_pts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># 3D control points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">spline</span><span class=\"o\">.</span><span class=\"n\">plotPV</span><span class=\"p\">(</span><span class=\"n\">ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">pv_plotter</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"s1\">&#39;pv.Plotter&#39;</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ctrl_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#d95f02&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">interior_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#666666&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">elem_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#7570b3&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">border_color</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#1b9e77&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"s1\">&#39;pv.Plotter&#39;</span><span class=\"p\">)]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis", "modulename": "bsplyne.b_spline_basis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis", "kind": "class", "doc": "<p>BSpline basis in 1D.</p>\n\n<p>A class representing a one-dimensional B-spline basis with functionality for evaluation, \nmanipulation and visualization of basis functions. Provides methods for basis function \nevaluation, derivatives computation, knot insertion, order elevation, and integration \npoint generation.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>p</strong> (int):\nDegree of the polynomials composing the basis.</li>\n<li><strong>knot</strong> (np.ndarray[np.floating]):\nKnot vector defining the B-spline basis. Contains non-decreasing sequence \nof isoparametric coordinates.</li>\n<li><strong>m</strong> (int):\nLast index of the knot vector (size - 1).</li>\n<li><strong>n</strong> (int):\nLast index of the basis functions. When evaluated, returns an array of size \n<code>n + 1</code>.</li>\n<li><strong>span</strong> (tuple[float, float]):\nInterval of definition of the basis <code>(knot[p], knot[m - p])</code>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The basis functions are defined over the isoparametric space specified by the knot vector.\nBasis function evaluation and manipulation methods use efficient algorithms based on \nCox-de Boor recursion formulas.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>numpy.ndarray</code>:  Array type used for knot vector storage<br />\n<code>scipy.sparse</code>:  Sparse matrix formats used for basis function evaluations  </p>\n"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.__init__", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.__init__", "kind": "function", "doc": "<p>Initialize a B-spline basis with specified degree and knot vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>p</strong> (int):\nDegree of the B-spline polynomials.</li>\n<li><strong>knot</strong> (Iterable[float]):\nKnot vector defining the B-spline basis. Must be a non-decreasing sequence \nof real numbers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>BSplineBasis</strong>: The initialized <code>BSplineBasis</code> instance.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The knot vector must satisfy these conditions:</p>\n\n<ul>\n<li>Size must be at least <code>p + 2</code></li>\n<li>Must be non-decreasing</li>\n<li>For non closed B-spline curves, first and last knots must have multiplicity <code>p + 1</code></li>\n</ul>\n\n<p>The basis functions are defined over the isoparametric space specified by \nthe knot vector. The span of the basis is [<code>knot[p]</code>, <code>knot[m - p]</code>], where\n<code>m</code> is the last index of the knot vector.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Create a quadratic B-spline basis with uniform knot vector:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">knot</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.p", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.p", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.knot", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.knot", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray[numpy.floating]"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.m", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.m", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.n", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.n", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.span", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.span", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[float, float]"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.linspace", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.linspace", "kind": "function", "doc": "<p>Generate evenly spaced points over the basis span.</p>\n\n<p>Creates a set of evaluation points by distributing them uniformly within each knot span \n(element) of the basis. Points are evenly spaced within elements but spacing may vary \nbetween different elements.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (int, optional):\nNumber of evaluation points per element. By default, 10.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xi</strong> (np.ndarray[np.floating]):\nArray of evenly spaced points in isoparametric coordinates over the basis span.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The method:</p>\n\n<ol>\n<li>Identifies unique knot spans (elements) in the isoparametric space</li>\n<li>Distributes points evenly within each element</li>\n<li>Combines points from all elements into a single array</li>\n</ol>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"go\">array([0. , 0.2, 0.4, 0.6, 0.8, 1. ])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.linspace_for_integration", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.linspace_for_integration", "kind": "function", "doc": "<p>Generate points and weights for numerical integration over knot spans in the \nisoparametric space. Points are evenly distributed within each element (knot span),\nthough spacing may vary between different elements.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (int, optional):\nNumber of evaluation points per element. By default, 10.</li>\n<li><strong>bounding_box</strong> (Union[tuple[float, float], None], optional):\nLower and upper bounds for integration. If <code>None</code>, uses the span of the basis.\nBy default, None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xi</strong> (np.ndarray[np.floating]):\nArray of integration points in isoparametric coordinates, evenly spaced \nwithin each element.</li>\n<li><strong>dxi</strong> (np.ndarray[np.floating]):\nArray of corresponding integration weights, which may vary between elements</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The method generates integration points by:</p>\n\n<ol>\n<li>Identifying unique knot spans (elements) in the isoparametric space</li>\n<li>Distributing points evenly within each element</li>\n<li>Computing appropriate weights for each point based on the element size</li>\n</ol>\n\n<p>When <code>bounding_box</code> is provided, integration is restricted to that interval,\nand elements are adjusted accordingly.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">dxi</span> <span class=\"o\">=</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">linspace_for_integration</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">bounding_box</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.gauss_legendre_for_integration", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.gauss_legendre_for_integration", "kind": "function", "doc": "<p>Generate Gauss-Legendre quadrature points and weights for numerical integration over the B-spline basis.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_eval_per_elem</strong> (Union[int, None], optional):\nNumber of evaluation points per element. If <code>None</code>, takes the value <code>self.p//2 + 1</code>.\nBy default, None.</li>\n<li><strong>bounding_box</strong> (Union[tuple[float, float], None], optional):\nLower and upper bounds for integration. If <code>None</code>, uses the span of the basis.\nBy default, None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xi</strong> (np.ndarray[np.floating]):\nArray of Gauss-Legendre quadrature points in isoparametric coordinates.</li>\n<li><strong>dxi</strong> (np.ndarray[np.floating]):\nArray of corresponding integration weights.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The method generates integration points and weights by:</p>\n\n<ol>\n<li>Identifying unique knot spans (elements) in the isoparametric space</li>\n<li>Computing Gauss-Legendre points and weights for each element</li>\n<li>Transforming points and weights to account for element size</li>\n</ol>\n\n<p>When <code>bounding_box</code> is provided, integration is restricted to that interval.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">dxi</span> <span class=\"o\">=</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">gauss_legendre_for_integration</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xi</span>  <span class=\"c1\"># Gauss-Legendre points</span>\n<span class=\"go\">array([0.11270167, 0.5       , 0.88729833])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dxi</span>  <span class=\"c1\"># Integration weights</span>\n<span class=\"go\">array([0.27777778, 0.44444444, 0.27777778])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounding_box</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.normalize_knots", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.normalize_knots", "kind": "function", "doc": "<p>Normalize the knot vector to the interval [0, 1].</p>\n\n<p>Maps the knot vector to the unit interval by applying an affine transformation that \npreserves the relative spacing between knots. Updates both the knot vector and span \nattributes.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"mf\">2.</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">normalize_knots</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">knot</span>\n<span class=\"go\">array([0., 0., 0., 1., 1., 1.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">span</span>\n<span class=\"go\">(0, 1)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.N", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.N", "kind": "function", "doc": "<p>Compute the k-th derivative of the B-spline basis functions at specified points.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>XI</strong> (np.ndarray[np.floating]):\nPoints in the isoparametric space at which to evaluate the basis functions.</li>\n<li><strong>k</strong> (int, optional):\nOrder of the derivative to compute. By default, 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>DN</strong> (sps.coo_matrix):\nSparse matrix containing the k-th derivative values. Each row corresponds to an \nevaluation point, each column to a basis function. Shape is (<code>XI.size</code>, <code>n + 1</code>).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses Cox-de Boor recursion formulas to compute basis function derivatives.\nReturns values in sparse matrix format for efficient storage and computation.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">A</span>  <span class=\"c1\"># Evaluate basis functions</span>\n<span class=\"go\">array([[1.  , 0.  , 0.  ],</span>\n<span class=\"go\">    [0.25, 0.5 , 0.25],</span>\n<span class=\"go\">    [0.  , 0.  , 1.  ]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">A</span>  <span class=\"c1\"># Evaluate first derivatives</span>\n<span class=\"go\">array([[-2.,  2.,  0.],</span>\n<span class=\"go\">    [-1.,  0.,  1.],</span>\n<span class=\"go\">    [ 0., -2.,  2.]])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">XI</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_coo</span><span class=\"o\">.</span><span class=\"n\">coo_matrix</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.to_dict", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.to_dict", "kind": "function", "doc": "<p>Returns a dictionary representation of the BSplineBasis object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.from_dict", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.from_dict", "kind": "function", "doc": "<p>Creates a BSplineBasis object from a dictionary representation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline_basis</span><span class=\"o\">.</span><span class=\"n\">BSplineBasis</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.save", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.save", "kind": "function", "doc": "<p>Save the BSplineBasis object to a file.\nControl points are optional.\nSupported extensions: json, pkl</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.load", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.load", "kind": "function", "doc": "<p>Load a BSplineBasis object from a file.\nMay return control points if the file contains them.\nSupported extensions: json, pkl</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline_basis</span><span class=\"o\">.</span><span class=\"n\">BSplineBasis</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.plotN", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.plotN", "kind": "function", "doc": "<p>Plot the B-spline basis functions or their derivatives over the span.</p>\n\n<p>Visualizes each basis function N_i(\u03be) or its k-th derivative over its support interval \nusing matplotlib. The plot includes proper LaTeX labels and a legend if there are 10 or \nfewer basis functions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (int, optional):\nOrder of derivative to plot. By default, 0 (plots the basis functions themselves).</li>\n<li><strong>show</strong> (bool, optional):\nWhether to display the plot immediately. Can be useful to add more stuff to the plot. \nBy default, True.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Uses adaptive sampling with points only in regions where basis functions are non-zero</li>\n<li>Plots each basis function in a different color with LaTeX-formatted labels</li>\n<li>Legend is automatically hidden if there are more than 10 basis functions</li>\n<li>The x-axis represents the isoparametric coordinate \u03be</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">plotN</span><span class=\"p\">()</span>  <span class=\"c1\"># Plot basis functions</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">plotN</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># Plot first derivatives</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.knotInsertion", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.knotInsertion", "kind": "function", "doc": "<p>Insert knots into the B-spline basis and return the transformation matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>knots_to_add</strong> (np.ndarray[np.floating]):\nArray of knots to insert into the knot vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>D</strong> (sps.coo_matrix):\nTransformation matrix such that new control points = <code>D</code> @ old control points.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Updates the basis by:</p>\n\n<ul>\n<li>Inserting new knots into the knot vector</li>\n<li>Incrementing <code>m</code> and <code>n</code> by the number of inserted knots</li>\n<li>Computing transformation matrix <code>D</code> for control points update</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">knotInsertion</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.33</span><span class=\"p\">,</span> <span class=\"mf\">0.67</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">A</span>\n<span class=\"go\">array([[1.    , 0.    , 0.    ],</span>\n<span class=\"go\">       [0.67  , 0.33  , 0.    ],</span>\n<span class=\"go\">       [0.2211, 0.5578, 0.2211],</span>\n<span class=\"go\">       [0.    , 0.33  , 0.67  ],</span>\n<span class=\"go\">       [0.    , 0.    , 1.    ]])</span>\n</code></pre>\n</div>\n\n<p>The knot vector is modified (as well as n and m) :</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">knot</span>\n<span class=\"go\">array([0.  , 0.  , 0.  , 0.33, 0.67, 1.  , 1.  , 1.  ])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">knots_to_add</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_coo</span><span class=\"o\">.</span><span class=\"n\">coo_matrix</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.orderElevation", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.orderElevation", "kind": "function", "doc": "<p>Elevate the polynomial degree of the B-spline basis and return the transformation matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (int):\nAmount by which to increase the basis degree. New degree will be current degree plus <code>t</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>STD</strong> (sps.coo_matrix):\nTransformation matrix for control points such that:\nnew_control_points = <code>STD</code> @ old_control_points</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The method:</p>\n\n<ol>\n<li>Separates B-spline into B\u00e9zier segments via knot insertion</li>\n<li>Elevates degree of each B\u00e9zier segment</li>\n<li>Recombines segments into elevated B-spline via knot removal</li>\n<li>Updates basis degree, knot vector and other attributes</li>\n</ol>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Elevate quadratic basis to cubic:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">orderElevation</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">A</span>\n<span class=\"go\">array([[1.        , 0.        , 0.        ],</span>\n<span class=\"go\">       [0.33333333, 0.66666667, 0.        ],</span>\n<span class=\"go\">       [0.        , 0.66666667, 0.33333333],</span>\n<span class=\"go\">       [0.        , 0.        , 1.        ]])</span>\n</code></pre>\n</div>\n\n<p>The knot vector and the degree are modified (as well as n and m) :</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">knot</span>\n<span class=\"go\">array([0., 0., 0., 0., 1., 1., 1., 1.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">p</span>\n<span class=\"go\">3</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_coo</span><span class=\"o\">.</span><span class=\"n\">coo_matrix</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.b_spline_basis.BSplineBasis.greville_abscissa", "modulename": "bsplyne.b_spline_basis", "qualname": "BSplineBasis.greville_abscissa", "kind": "function", "doc": "<p>Compute the Greville abscissa and optionally their weights for this 1D B-spline basis.</p>\n\n<p>The Greville abscissa represent the parametric coordinates associated with each\ncontrol point. They are defined as the average of <code>p</code> consecutive internal knots.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>return_weights</strong> (bool, optional):\nIf <code>True</code>, also returns the weights (support lengths) associated with each basis function.\nBy default, False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>greville</strong> (np.ndarray[np.floating]):\nArray containing the Greville abscissa of size <code>n + 1</code>, where <code>n</code> is the last index\nof the basis functions in this 1D basis.</li>\n<li><strong>weight</strong> (np.ndarray[np.floating], optional):\nOnly returned if <code>return_weights</code> is <code>True</code>.\nArray of the same size as <code>greville</code>, containing the length of the support of\neach basis function (difference between the end and start knots of its support).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The Greville abscissa are computed as the average of <code>p</code> consecutive knots:\nfor the i-th basis function, its abscissa is\n(knot[i+1] + knot[i+2] + ... + knot[i+p]) / p</li>\n<li>The weights represent the length of the support of each basis function,\ncomputed as knot[i+p+1] - knot[i].</li>\n<li>The number of abscissa equals the number of control points.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">degree</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">knot</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">BSplineBasis</span><span class=\"p\">(</span><span class=\"n\">degree</span><span class=\"p\">,</span> <span class=\"n\">knot</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span> <span class=\"o\">=</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">greville_abscissa</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span>\n<span class=\"go\">array([0.  , 0.25, 0.75, 1.  ])</span>\n</code></pre>\n</div>\n\n<p>Compute both abscissa and weights:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">greville</span><span class=\"p\">,</span> <span class=\"n\">weight</span> <span class=\"o\">=</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">greville_abscissa</span><span class=\"p\">(</span><span class=\"n\">return_weights</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">weight</span>\n<span class=\"go\">array([0.5, 1. , 1. , 0.5])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">return_weights</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D", "modulename": "bsplyne.geometries_in_3D", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.geometries_in_3D.scale_rotate_translate", "modulename": "bsplyne.geometries_in_3D", "qualname": "scale_rotate_translate", "kind": "function", "doc": "<p>Applies a scale, rotation and translation to a set of points.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>pts</strong> (array_like):\nThe points to be transformed.</li>\n<li><strong>scale_vector</strong> (array_like):\nThe vector to scale by.</li>\n<li><strong>axis</strong> (array_like):\nThe axis to rotate around.</li>\n<li><strong>angle</strong> (float):\nThe angle to rotate by in radians.</li>\n<li><strong>translation_vector</strong> (array_like):\nThe vector to translate by.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>new_pts</strong> (array_like):\nThe transformed points.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pts</span>, </span><span class=\"param\"><span class=\"n\">scale_vector</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">translation_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_quarter_circle", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_quarter_circle", "kind": "function", "doc": "<p>Creates a B-spline quarter circle from a given center, normal and radius.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the quarter circle.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the quarter circle.</li>\n<li><strong>radius</strong> (float):\nThe radius of the quarter circle.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>quarter_circle</strong> (BSpline):\nThe quarter circle.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the quarter circle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_circle", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_circle", "kind": "function", "doc": "<p>Create a B-spline circle in 3D space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the circle.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the circle.</li>\n<li><strong>radius</strong> (float):\nThe radius of the circle.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>circle</strong> (BSpline):\nThe circle.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the circle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_disk", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_disk", "kind": "function", "doc": "<p>Creates a B-spline disk from a given center, normal and radius.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the disk.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the disk.</li>\n<li><strong>radius</strong> (float):\nThe radius of the disk.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>disk</strong> (BSpline):\nThe disk.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the disk.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_degenerated_disk", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_degenerated_disk", "kind": "function", "doc": "<p>Creates a B-spline degenerated disk from a given center, normal and radius.\nThe disk is degenerated as it is created by \"blowing\" a square into a circle.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the degenerated disk.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the degenerated disk.</li>\n<li><strong>radius</strong> (float):\nThe radius of the degenerated disk.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>disk</strong> (BSpline):\nThe degenerated disk.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the degenerated disk.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_quarter_pipe", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_quarter_pipe", "kind": "function", "doc": "<p>Creates a B-spline quarter pipe from a given center, orientation, radius and length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the quarter pipe.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the quarter pipe.</li>\n<li><strong>radius</strong> (float):\nThe radius of the quarter pipe.</li>\n<li><strong>length</strong> (float):\nThe length of the quarter pipe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>quarter_pipe</strong> (BSpline):\nThe quarter pipe.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the quarter pipe.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_pipe", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_pipe", "kind": "function", "doc": "<p>Creates a B-spline pipe from a given center, orientation, radius and length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the pipe.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the pipe.</li>\n<li><strong>radius</strong> (float):\nThe radius of the pipe.</li>\n<li><strong>length</strong> (float):\nThe length of the pipe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pipe</strong> (BSpline):\nThe pipe.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the pipe.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_quarter_cylinder", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_quarter_cylinder", "kind": "function", "doc": "<p>Creates a B-spline quarter cylinder from a given center, orientation, radius and length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the quarter cylinder.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the quarter cylinder.</li>\n<li><strong>radius</strong> (float):\nThe radius of the quarter cylinder.</li>\n<li><strong>length</strong> (float):\nThe length of the quarter cylinder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>quarter_cylinder</strong> (BSpline):\nThe quarter cylinder.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the quarter cylinder.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_cylinder", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_cylinder", "kind": "function", "doc": "<p>Creates a B-spline cylinder from a given center, orientation, radius and length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the cylinder.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the cylinder.</li>\n<li><strong>radius</strong> (float):\nThe radius of the cylinder.</li>\n<li><strong>length</strong> (float):\nThe length of the cylinder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cylinder</strong> (BSpline):\nThe cylinder.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the cylinder.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_degenerated_cylinder", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_degenerated_cylinder", "kind": "function", "doc": "<p>Creates a B-spline cylinder from a given center, orientation, radius and length.\nThe cylinder is degenerated as it is created by \"blowing\" a square into a circle \nbefore extruding it into a cylinder.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the cylinder.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the cylinder.</li>\n<li><strong>radius</strong> (float):\nThe radius of the cylinder.</li>\n<li><strong>length</strong> (float):\nThe length of the cylinder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cylinder</strong> (BSpline):\nThe cylinder.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the cylinder.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_closed_circle", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_closed_circle", "kind": "function", "doc": "<p>Creates a B-spline circle from a given center, normal and radius.\nThe circle is closed as it the junction between the start and the end of the \nparametric space spans enough elements to conserve the C^(p-1) continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the circle.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the circle.</li>\n<li><strong>radius</strong> (float):\nThe radius of the circle.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>circle</strong> (BSpline):\nThe circle.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the circle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_closed_disk", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_closed_disk", "kind": "function", "doc": "<p>Creates a B-spline disk from a given center, normal and radius.\nThe disk is closed as it the junction between the start and the end of the \nparametric space spans enough elements to conserve the C^(p-1) continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the disk.</li>\n<li><strong>normal</strong> (array_like):\nThe normal vector of the disk.</li>\n<li><strong>radius</strong> (float):\nThe radius of the disk.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>disk</strong> (BSpline):\nThe disk.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the disk.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_closed_pipe", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_closed_pipe", "kind": "function", "doc": "<p>Creates a B-spline closed pipe from a given center, orientation, radius and length.\nThe pipe is closed as the junction between the start and the end of the \nparametric space along the circular direction spans enough elements to conserve the\nC^(p-1) continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the pipe.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the pipe.</li>\n<li><strong>radius</strong> (float):\nThe radius of the pipe.</li>\n<li><strong>length</strong> (float):\nThe length of the pipe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pipe</strong> (BSpline):\nThe pipe.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the pipe.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_closed_cylinder", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_closed_cylinder", "kind": "function", "doc": "<p>Creates a B-spline closed cylinder from a given center, orientation, radius and length.\nThe cylinder is closed as the junction between the start and the end of the \nparametric space along the circular direction spans enough elements to conserve the\nC^(p-1) continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the closed cylinder.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the closed cylinder.</li>\n<li><strong>radius</strong> (float):\nThe radius of the closed cylinder.</li>\n<li><strong>length</strong> (float):\nThe length of the closed cylinder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>closed_cylinder</strong> (BSpline):\nThe closed cylinder.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the closed cylinder.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_quarter_strut", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_quarter_strut", "kind": "function", "doc": "<p>Creates a B-spline quarter strut from a given center, orientation, radius and length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center_front</strong> (array_like):\nThe center of the front of the quarter strut.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the quarter strut.</li>\n<li><strong>radius</strong> (float):\nThe radius of the quarter strut.</li>\n<li><strong>length</strong> (float):\nThe length of the quarter strut.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>quarter_strut</strong> (BSpline):\nThe quarter strut.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the quarter strut.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center_front</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.geometries_in_3D.new_cube", "modulename": "bsplyne.geometries_in_3D", "qualname": "new_cube", "kind": "function", "doc": "<p>Creates a B-spline cube from a given center, orientation and side length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>center</strong> (array_like):\nThe center of the cube.</li>\n<li><strong>orientation</strong> (array_like):\nThe normal vector of the cube.</li>\n<li><strong>side_length</strong> (float):\nThe side length of the cube.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cube</strong> (BSpline):\nThe cube.</li>\n<li><strong>ctrlPts</strong> (array_like):\nThe control points of the cube.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">orientation</span>, </span><span class=\"param\"><span class=\"n\">side_length</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline", "modulename": "bsplyne.multi_patch_b_spline", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity", "kind": "class", "doc": "<p>Contains all the methods to link multiple B-spline patches.\nIt uses 3 representations of the data : </p>\n\n<ul>\n<li>a unique representation, possibly common with other meshes, containing \nonly unique nodes indices, </li>\n<li>a unpacked representation containing duplicated nodes indices, </li>\n<li>a separated representation containing duplicated nodes indices, \nseparated between patches. It is here for user friendliness.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>unique_nodes_inds</strong> (numpy.ndarray of int):\nThe indices of the unique representation needed to create the unpacked one.</li>\n<li><strong>shape_by_patch</strong> (numpy.ndarray of int):\nThe shape of the separated nodes by patch.</li>\n<li><strong>nb_nodes</strong> (int):\nThe total number of unpacked nodes.</li>\n<li><strong>nb_unique_nodes</strong> (int):\nThe total number of unique nodes.</li>\n<li><strong>nb_patchs</strong> (int):\nThe number of patches.</li>\n<li><strong>npa</strong> (int):\nThe dimension of the parametric space of the B-splines.</li>\n</ul>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.__init__", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.__init__", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>unique_nodes_inds</strong> (numpy.ndarray of int):\nThe indices of the unique representation needed to create the unpacked one.</li>\n<li><strong>shape_by_patch</strong> (numpy.ndarray of int):\nThe shape of the separated nodes by patch.</li>\n<li><strong>nb_unique_nodes</strong> (int):\nThe total number of unique nodes.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unique_nodes_inds</span>, </span><span class=\"param\"><span class=\"n\">shape_by_patch</span>, </span><span class=\"param\"><span class=\"n\">nb_unique_nodes</span></span>)</span>"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.unique_nodes_inds", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.unique_nodes_inds", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.shape_by_patch", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.shape_by_patch", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.nb_nodes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.nb_nodes", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.nb_unique_nodes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.nb_unique_nodes", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.nb_patchs", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.nb_patchs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.npa", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.npa", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.from_nodes_couples", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.from_nodes_couples", "kind": "function", "doc": "<p>Create the connectivity from a list of couples of unpacked nodes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nodes_couples</strong> (numpy.ndarray of int):\nCouples of indices of unpacked nodes that are considered the same.\nIts shape should be (# of couples, 2)</li>\n<li><strong>shape_by_patch</strong> (numpy.ndarray of int):\nThe shape of the separated nodes by patch.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>MultiPatchBSplineConnectivity</strong>: Instance of <code>MultiPatchBSplineConnectivity</code> created.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">nodes_couples</span>, </span><span class=\"param\"><span class=\"n\">shape_by_patch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.from_separated_ctrlPts", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.from_separated_ctrlPts", "kind": "function", "doc": "<p>Create the connectivity from a list of control points given as \na separated field by comparing every couple of points.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>separated_ctrlPts</strong> (list of numpy.ndarray of float):\nControl points of every patch to be compared in the separated \nrepresentation. Every array is of shape : \n(<code>NPh</code>, nb elem for dim 1, ..., nb elem for dim <code>npa</code>)</li>\n<li><strong>eps</strong> (float, optional):\nMaximum distance between two points to be considered the same, by default 1e-10</li>\n<li><strong>return_nodes_couples</strong> (bool, optional):\nIf <code>True</code>, returns the <code>nodes_couples</code> created, by default False</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>MultiPatchBSplineConnectivity</strong>: Instance of <code>MultiPatchBSplineConnectivity</code> created.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrlPts</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span>,</span><span class=\"param\">\t<span class=\"n\">return_nodes_couples</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.unpack", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.unpack", "kind": "function", "doc": "<p>Extract the unpacked representation from a unique representation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>unique_field</strong> (numpy.ndarray):\nThe unique representation. Its shape should be :\n(field, shape, ..., <code>self</code>.<code>nb_unique_nodes</code>)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unpacked_field</strong> (numpy.ndarray):\nThe unpacked representation. Its shape is :\n(field, shape, ..., <code>self</code>.<code>nb_nodes</code>)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">unique_field</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.pack", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.pack", "kind": "function", "doc": "<p>Extract the unique representation from an unpacked representation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>unpacked_field</strong> (numpy.ndarray):\nThe unpacked representation. Its shape should be :\n(field, shape, ..., <code>self</code>.<code>nb_nodes</code>)</li>\n<li><strong>method</strong> (str):\nThe method used to group values that could be different</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unique_nodes</strong> (numpy.ndarray):\nThe unique representation. Its shape is :\n(field, shape, ..., <code>self</code>.<code>nb_unique_nodes</code>)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">unpacked_field</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;mean&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.separate", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.separate", "kind": "function", "doc": "<p>Extract the separated representation from an unpacked representation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>unpacked_field</strong> (numpy.ndarray):\nThe unpacked representation. Its shape is :\n(field, shape, ..., <code>self</code>.<code>nb_nodes</code>)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>separated_field</strong> (list of numpy.ndarray):\nThe separated representation. Every array is of shape : \n(field, shape, ..., nb elem for dim 1, ..., nb elem for dim <code>npa</code>)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">unpacked_field</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.agglomerate", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.agglomerate", "kind": "function", "doc": "<p>Extract the unpacked representation from a separated representation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>separated_field</strong> (list of numpy.ndarray):\nThe separated representation. Every array is of shape : \n(field, shape, ..., nb elem for dim 1, ..., nb elem for dim <code>npa</code>)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unpacked_field</strong> (numpy.ndarray):\nThe unpacked representation. Its shape is :\n(field, shape, ..., <code>self</code>.<code>nb_nodes</code>)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">separated_field</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.unique_field_indices", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.unique_field_indices", "kind": "function", "doc": "<p>Get the unique, unpacked or separated representation of a field's unique indices.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field_shape</strong> (tuple of int):\nThe shape of the field. For example, if it is a vector field, <code>field_shape</code> \nshould be (3,). If it is a second order tensor field, it should be (3, 3).</li>\n<li><strong>representation</strong> (str, optional):\nThe user must choose between <code>\"unique\"</code>, <code>\"unpacked\"</code>, and <code>\"separated\"</code>.\nIt corresponds to the type of representation to get, by default \"separated\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unique_field_indices</strong> (numpy.ndarray of int or list of numpy.ndarray of int):\nThe unique, unpacked or separated representation of a field's unique indices.\nIf unique, its shape is (<em><code>field_shape</code>, <code>self</code>.<code>nb_unique_nodes</code>).\nIf unpacked, its shape is : (</em><code>field_shape</code>, <code>self</code>.<code>nb_nodes</code>).\nIf separated, every array is of shape : (*<code>field_shape</code>, nb elem for dim 1, ..., nb elem for dim <code>npa</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">field_shape</span>, </span><span class=\"param\"><span class=\"n\">representation</span><span class=\"o\">=</span><span class=\"s1\">&#39;separated&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.get_duplicate_unpacked_nodes_mask", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.get_duplicate_unpacked_nodes_mask", "kind": "function", "doc": "<p>Returns a boolean mask indicating which nodes in the unpacked representation are duplicates.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>duplicate_nodes_mask</strong> (numpy.ndarray):\nBoolean mask of shape (nb_nodes,) where True indicates a node is duplicated \nacross multiple patches and False indicates it appears only once.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.extract_exterior_borders", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.extract_exterior_borders", "kind": "function", "doc": "<p>Extract exterior borders from B-spline patches.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (list[BSpline]):\nArray of B-spline patches to extract borders from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>border_connectivity</strong> (MultiPatchBSplineConnectivity):\nConnectivity information for the border patches.</li>\n<li><strong>border_splines</strong> (list[BSpline]):\nArray of B-spline patches representing the borders.</li>\n<li><strong>border_unique_to_self_unique_connectivity</strong> (numpy.ndarray of int):\nArray mapping border unique nodes to original unique nodes.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If isoparametric space dimension is less than 2.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">splines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.extract_interior_borders", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.extract_interior_borders", "kind": "function", "doc": "<p>Extract interior borders from B-spline patches where nodes are shared between patches.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (list[BSpline]):\nArray of B-spline patches to extract borders from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>border_connectivity</strong> (MultiPatchBSplineConnectivity):\nConnectivity information for the border patches.</li>\n<li><strong>border_splines</strong> (list[BSpline]):\nArray of B-spline patches representing the borders.</li>\n<li><strong>border_unique_to_self_unique_connectivity</strong> (numpy.ndarray of int):\nArray mapping border unique nodes to original unique nodes.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If parametric space dimension is less than 2.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">splines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.subset", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.subset", "kind": "function", "doc": "<p>Create a subset of the multi-patch B-spline connectivity by keeping only selected patches.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (list[BSpline]):\nArray of B-spline patches to subset.</li>\n<li><strong>patches_to_keep</strong> (numpy.array of int):\nIndices of patches to keep in the subset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>new_connectivity</strong> (MultiPatchBSplineConnectivity):\nNew connectivity object containing only the selected patches.</li>\n<li><strong>new_splines</strong> (list[BSpline]):\nArray of B-spline patches for the selected patches.</li>\n<li><strong>new_unique_to_self_unique_connectivity</strong> (numpy.ndarray of int):\nArray mapping new unique nodes to original unique nodes.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">splines</span>, </span><span class=\"param\"><span class=\"n\">patches_to_keep</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.make_control_poly_meshes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.make_control_poly_meshes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">unique_fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">separated_fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI_list</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paraview_sizes</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.make_elem_separator_meshes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.make_elem_separator_meshes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">unique_fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">separated_fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI_list</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paraview_sizes</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">parallel</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.make_elements_interior_meshes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.make_elements_interior_meshes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">unique_fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">separated_fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI_list</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parallel</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.make_all_meshes", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.make_all_meshes", "kind": "function", "doc": "<p>Generate all mesh representations (interior, element borders, and control points) for a multipatch B-spline geometry.</p>\n\n<p>This method creates three types of meshes for visualization or analysis:</p>\n\n<ul>\n<li>The interior mesh representing the B-spline surface or volume.</li>\n<li>The element separator mesh showing the borders between elements.</li>\n<li>The control polygon mesh showing the control structure.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (Iterable[BSpline]):\nList of B-spline patches to process.</li>\n<li><strong>separated_ctrl_pts</strong> (Iterable[np.ndarray[np.floating]]):\nControl points for each patch in separated representation.</li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to generate. By default, 1.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nIf an <code>int</code> is provided, the same number is used for all dimensions.\nIf an <code>Iterable</code> is provided, each value corresponds to a different dimension.\nBy default, 10.</li>\n<li><strong>unique_fields</strong> (dict, optional):\nFields in unique representation to visualize. By default, <code>{}</code>.\nKeys are field names, values are arrays (not callables nor FE fields).</li>\n<li><strong>separated_fields</strong> (Union[list[dict], None], optional):\nFields to visualize at each time step.\nList of <code>self.nb_patchs</code> dictionaries (one per patch) of format:\n{\n    \"field_name\": <code>field_value</code>\n}\nwhere <code>field_value</code> can be either:\n<ol>\n<li>A <code>np.ndarray</code> with shape (<code>n_step</code>, <code>field_size</code>, <code>self.shape_by_patch[patch]</code>)</li>\n<li>A <code>np.ndarray</code> with shape (<code>n_step</code>, <code>field_size</code>, <code>*grid_shape</code>)</li>\n<li>A function that computes field values (<code>np.ndarray[np.floating]</code>) at given points from the <code>BSpline</code> instance and <code>XI</code>.\nBy default, None.</li>\n</ol></li>\n<li><strong>XI_list</strong> (Union[None, Iterable[tuple[np.ndarray[np.floating], ...]]], optional):\nParametric coordinates at which to evaluate the B-spline patches and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, regular grids are generated according to <code>n_eval_per_elem</code>.\nBy default, None.</li>\n<li><strong>verbose</strong> (bool, optional):\nWhether to print progress information. By default, True.</li>\n<li><strong>fiels_on_interior_only</strong> (Union[bool, Literal['auto'], list[str]], optionnal):\nWhether to include fields only on the interior mesh (<code>True</code>), on all meshes (<code>False</code>),\nor on specified field names.\nIf set to <code>'auto'</code>, fields named <code>'u'</code>, <code>'U'</code>, <code>'displacement'</code> or <code>'displ'</code> \nare included on all meshes while others are only included on the interior mesh.\nBy default, 'auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple[list[io.Mesh], list[io.Mesh], list[io.Mesh]]</strong>: Tuple containing three lists of <code>io.Mesh</code> objects:\n<ul>\n<li>Interior meshes for each time step.</li>\n<li>Element separator meshes for each time step.</li>\n<li>Control polygon meshes for each time step.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>NotImplementedError</strong>: If a callable is passed in <code>unique_fields</code>.</li>\n<li><strong>ValueError</strong>: If a field in <code>unique_fields</code> does not have the correct shape.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The isoparametric space refers to the parametric space of the B-splines.</li>\n<li>Fields can be visualized as scalars or vectors.</li>\n<li>Supports time-dependent visualization through <code>n_step</code>.</li>\n<li>Fields in <code>unique_fields</code> must be arrays; to use callables, use <code>separated_fields</code>.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">interior</span><span class=\"p\">,</span> <span class=\"n\">borders</span><span class=\"p\">,</span> <span class=\"n\">control</span> <span class=\"o\">=</span> <span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">make_all_meshes</span><span class=\"p\">(</span><span class=\"n\">splines</span><span class=\"p\">,</span> <span class=\"n\">separated_ctrl_pts</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">unique_fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">separated_fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI_list</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">fields_on_interior_only</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.MultiPatchBSplineConnectivity.save_paraview", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "MultiPatchBSplineConnectivity.save_paraview", "kind": "function", "doc": "<p>Save multipatch B-spline visualization data as Paraview files.</p>\n\n<p>This method generates three types of visualization files for a multipatch B-spline geometry:</p>\n\n<ul>\n<li>Interior mesh showing the B-spline surface/volume</li>\n<li>Element borders showing the mesh structure</li>\n<li>Control points mesh showing the control structure</li>\n</ul>\n\n<p>All files are saved in VTU format, with an optional PVD file to group them for Paraview.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (Iterable[BSpline]):\nList of B-spline patches to save.</li>\n<li><strong>separated_ctrl_pts</strong> (Iterable[np.ndarray[np.floating]]):\nControl points for each patch in separated representation.</li>\n<li><strong>path</strong> (str):\nDirectory path where the files will be saved.</li>\n<li><strong>name</strong> (str):\nBase name for the output files.</li>\n<li><strong>n_step</strong> (int, optional):\nNumber of time steps to save. By default, 1.</li>\n<li><strong>n_eval_per_elem</strong> (Union[int, Iterable[int]], optional):\nNumber of evaluation points per element for each isoparametric dimension.\nIf an <code>int</code> is provided, the same number is used for all dimensions.\nIf an <code>Iterable</code> is provided, each value corresponds to a different dimension.\nBy default, 10.</li>\n<li><strong>unique_fields</strong> (dict, optional):\nFields in unique representation to save. By default, <code>{}</code>.\nKeys are field names, values are arrays (not callables nor FE fields).</li>\n<li><p><strong>separated_fields</strong> (Union[list[dict], None], optional):\nFields to visualize at each time step.\nList of <code>self.nb_patchs</code> dictionaries (one per patch) of format:\n{\n    \"field_name\": <code>field_value</code>\n}\nwhere <code>field_value</code> can be either:</p>\n\n<ol>\n<li>A numpy array with shape (<code>n_step</code>, <code>field_size</code>, <code>self.shape_by_patch[patch]</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n<li><code>self.shape_by_patch[patch]</code>: Same shape as the patch's control points grid (excluding <code>NPh</code>)</li>\n</ul>\n\n<ol start=\"2\">\n<li>A numpy array with shape (<code>n_step</code>, <code>field_size</code>, <code>*grid_shape</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n<li><code>*grid_shape</code>: Shape of the evaluation grid (number of points along each isoparametric axis)</li>\n</ul>\n\n<ol start=\"3\">\n<li>A function that computes field values (<code>np.ndarray[np.floating]</code>) at given \npoints from the <code>BSpline</code> instance and <code>XI</code>, the tuple of arrays containing evaluation \npoints for each dimension (<code>tuple[np.ndarray[np.floating], ...]</code>).\nThe result should be an array of shape (<code>n_step</code>, <code>n_points</code>, <code>field_size</code>) where:</li>\n</ol>\n\n<ul>\n<li><code>n_step</code>: Number of time steps</li>\n<li><code>n_points</code>: Number of evaluation points (n_xi \u00d7 n_eta \u00d7 ...)</li>\n<li><code>field_size</code>: Size of the field at each point (1 for scalar, 3 for vector)</li>\n</ul>\n\n<p>By default, None.</p></li>\n<li><strong>XI_list</strong> (Iterable[tuple[np.ndarray[np.floating], ...]], optional):\nParametric coordinates at which to evaluate the B-spline patches and fields.\nIf not <code>None</code>, overrides the <code>n_eval_per_elem</code> parameter.\nIf <code>None</code>, regular grids are generated according to <code>n_eval_per_elem</code>.</li>\n<li><strong>groups</strong> (Union[dict[str, dict[str, Union[str, int]]], None], optional):\nNested dictionary specifying file groups for PVD organization. Format:\n{\n    \"group_name\": {\n        \"ext\": str,     # File extension (e.g., \"vtu\")\n        \"npart\": int,   # Number of parts in the group\n        \"nstep\": int    # Number of timesteps\n    }\n}\nIf provided, existing groups are updated; if <code>None</code>, groups are created automatically.\nBy default, <code>None</code>.</li>\n<li><strong>make_pvd</strong> (bool, optional):\nWhether to create a PVD file grouping all VTU files. By default, <code>True</code>.</li>\n<li><strong>verbose</strong> (bool, optional):\nWhether to print progress information. By default, <code>True</code>.</li>\n<li><strong>fields_on_interior_only</strong> (Union[bool, Literal['auto'], list[str]], optionnal):\nWhether to include fields only on the interior mesh (<code>True</code>), on all meshes (<code>False</code>),\nor on specified field names.\nIf set to <code>'auto'</code>, fields named <code>'u'</code>, <code>'U'</code>, <code>'displacement'</code> or <code>'displ'</code> \nare included on all meshes while others are only included on the interior mesh.\nBy default, 'auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>groups</strong> (dict[str, dict[str, Union[str, int]]]):\nUpdated groups dictionary with information about saved files.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>NotImplementedError</strong>: If a callable is passed in <code>unique_fields</code>.</li>\n<li><strong>ValueError</strong>: If the multiprocessing pool is not running and cannot be restarted.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Creates three types of VTU files for each time step:\n<ul>\n<li>{name}_interior_{part}_{step}.vtu</li>\n<li>{name}_elements_borders_{part}_{step}.vtu</li>\n<li>{name}_control_points_{part}_{step}.vtu</li>\n</ul></li>\n<li>If <code>make_pvd=True</code>, creates a PVD file named {name}.pvd.</li>\n<li>Fields can be visualized as scalars or vectors in Paraview.</li>\n<li>The method supports time-dependent visualization through <code>n_step</code>.</li>\n<li>Fields in <code>unique_fields</code> must be arrays; to use callables, use <code>separated_fields</code>.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Save a multipatch B-spline visualization:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">save_paraview</span><span class=\"p\">(</span><span class=\"n\">splines</span><span class=\"p\">,</span> <span class=\"n\">separated_ctrl_pts</span><span class=\"p\">,</span> <span class=\"s2\">&quot;./output&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;multipatch&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Save with a custom separated field on a 2 patches multipatch:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"p\">[{</span><span class=\"s2\">&quot;temperature&quot;</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)},</span> <span class=\"p\">{</span><span class=\"s2\">&quot;temperature&quot;</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)}]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">save_paraview</span><span class=\"p\">(</span><span class=\"n\">splines</span><span class=\"p\">,</span> <span class=\"n\">separated_ctrl_pts</span><span class=\"p\">,</span> <span class=\"s2\">&quot;./output&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;multipatch&quot;</span><span class=\"p\">,</span> <span class=\"n\">separated_fields</span><span class=\"o\">=</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">separated_ctrl_pts</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">n_step</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">n_eval_per_elem</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">unique_fields</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">separated_fields</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">XI_list</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">floating</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groups</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">make_pvd</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">fields_on_interior_only</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.__init__", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spline1_inds</span>,</span><span class=\"param\">\t<span class=\"n\">spline2_inds</span>,</span><span class=\"param\">\t<span class=\"n\">axes1</span>,</span><span class=\"param\">\t<span class=\"n\">axes2</span>,</span><span class=\"param\">\t<span class=\"n\">front_sides1</span>,</span><span class=\"param\">\t<span class=\"n\">front_sides2</span>,</span><span class=\"param\">\t<span class=\"n\">transpose_2_to_1</span>,</span><span class=\"param\">\t<span class=\"n\">flip_2_to_1</span>,</span><span class=\"param\">\t<span class=\"n\">NPa</span></span>)</span>"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.spline1_inds", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.spline1_inds", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.spline2_inds", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.spline2_inds", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.axes1", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.axes1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.axes2", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.axes2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.front_sides1", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.front_sides1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.front_sides2", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.front_sides2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.transpose_2_to_1", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.transpose_2_to_1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.flip_2_to_1", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.flip_2_to_1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.NPa", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.NPa", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.nb_couples", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.nb_couples", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.extract_border_pts", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.extract_border_pts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">front_side</span>, </span><span class=\"param\"><span class=\"n\">field_dim</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.extract_border_spline", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.extract_border_spline", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">front_side</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.transpose_and_flip", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.transpose_and_flip", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">transpose</span>, </span><span class=\"param\"><span class=\"n\">flip</span>, </span><span class=\"param\"><span class=\"n\">field_dim</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.transpose_and_flip_knots", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.transpose_and_flip_knots", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">knots</span>, </span><span class=\"param\"><span class=\"n\">spans</span>, </span><span class=\"param\"><span class=\"n\">transpose</span>, </span><span class=\"param\"><span class=\"n\">flip</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.transpose_and_flip_back_knots", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.transpose_and_flip_back_knots", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">knots</span>, </span><span class=\"param\"><span class=\"n\">spans</span>, </span><span class=\"param\"><span class=\"n\">transpose</span>, </span><span class=\"param\"><span class=\"n\">flip</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.transpose_and_flip_spline", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.transpose_and_flip_spline", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">transpose</span>, </span><span class=\"param\"><span class=\"n\">flip</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.from_splines", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.from_splines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">separated_ctrl_pts</span>, </span><span class=\"param\"><span class=\"n\">splines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.append", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.append", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.get_operator_allxi1_to_allxi2", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.get_operator_allxi1_to_allxi2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spans1</span>, </span><span class=\"param\"><span class=\"n\">spans2</span>, </span><span class=\"param\"><span class=\"n\">couple_ind</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.get_connectivity", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.get_connectivity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape_by_patch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.get_borders_couples", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.get_borders_couples", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">separated_field</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.get_borders_couples_splines", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.get_borders_couples_splines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">splines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.multi_patch_b_spline.CouplesBSplineBorder.compute_border_couple_DN", "modulename": "bsplyne.multi_patch_b_spline", "qualname": "CouplesBSplineBorder.compute_border_couple_DN", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">couple_ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">splines</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">bsplyne</span><span class=\"o\">.</span><span class=\"n\">b_spline</span><span class=\"o\">.</span><span class=\"n\">BSpline</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">XI1_border</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">k1</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.my_wide_product", "modulename": "bsplyne.my_wide_product", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.my_wide_product.my_wide_product", "modulename": "bsplyne.my_wide_product", "qualname": "my_wide_product", "kind": "function", "doc": "<p>Compute a \"1D\" Kronecker product row by row.</p>\n\n<p>For each row i, the result C[i, :] = kron(A[i, :], B[i, :]).\nMatrices A and B must have the same number of rows.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>A</strong> (scipy.sparse.spmatrix):\nInput sparse matrix A in CSR format.</li>\n<li><strong>B</strong> (scipy.sparse.spmatrix):\nInput sparse matrix B in CSR format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>C</strong> (scipy.sparse.csr_matrix):\nResulting sparse matrix in CSR format with shape (A.shape[0], A.shape[1]*B.shape[1]).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">A</span><span class=\"p\">:</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_matrix</span><span class=\"o\">.</span><span class=\"n\">spmatrix</span>,</span><span class=\"param\">\t<span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_matrix</span><span class=\"o\">.</span><span class=\"n\">spmatrix</span></span><span class=\"return-annotation\">) -> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">_csr</span><span class=\"o\">.</span><span class=\"n\">csr_matrix</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.parallel_utils", "modulename": "bsplyne.parallel_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.parallel_utils.parallel_blocks_inner", "modulename": "bsplyne.parallel_utils", "qualname": "parallel_blocks_inner", "kind": "function", "doc": "<p>Execute a list of functions with their corresponding argument tuples, optionally in parallel blocks.</p>\n\n<p>This function performs the actual execution of tasks either sequentially or in parallel,\ndepending on the <code>disable_parallel</code> flag. When running in parallel, the tasks are divided into\n<code>num_blocks</code> groups (blocks), each executed by a separate worker process. Intermediate results\nare temporarily saved to disk as <code>.npy</code> files to limit memory usage and are reloaded sequentially\nafter all processes complete.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>funcs</strong> (Iterable[Callable]):\nList of functions to execute. Must have the same length as <code>all_args</code>.\nEach function is called as <code>func(*args)</code> for its corresponding argument tuple.</li>\n<li><strong>all_args</strong> (Iterable[tuple]):\nList of tuples, each containing the arguments for the corresponding function in <code>funcs</code>.</li>\n<li><strong>num_blocks</strong> (int):\nNumber of parallel blocks (i.e., worker processes) to use when <code>disable_parallel</code> is False.\nDetermines how many subsets of tasks will be distributed among processes.</li>\n<li><strong>verbose</strong> (bool):\nIf True, enables progress bars and displays information about block processing and result gathering.</li>\n<li><strong>pbar_title</strong> (str):\nTitle prefix used for progress bar descriptions.</li>\n<li><strong>disable_parallel</strong> (bool):\nIf True, all tasks are executed sequentially in the current process. If False, tasks are divided\ninto blocks and processed in parallel using a multiprocessing pool.</li>\n<li><strong>shared_mem_last_arg</strong> (Union[np.ndarray, None]):\nOptional NumPy array placed in shared memory and appended automatically as the last argument\nof each task. This is useful for sharing large read-only data (e.g., images, meshes) without\nduplicating memory across processes.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list</strong>: List of results obtained from applying each function to its corresponding argument tuple,\npreserving the original task order.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li><strong>Sequential mode:</strong> if <code>disable_parallel</code> is True, all functions are executed in the current\nprocess with an optional progress bar.</li>\n<li><strong>Parallel mode:</strong>\n<ul>\n<li>The tasks are split into <code>num_blocks</code> subsets.</li>\n<li>Each subset is processed by a separate worker via <code>multiprocessing.Pool</code>.</li>\n<li>Each worker writes its results as <code>.npy</code> files inside a temporary subfolder.</li>\n<li>After all workers complete, results are reloaded in the original order, and temporary files\nand folders are deleted.</li>\n</ul></li>\n<li><strong>Shared memory:</strong> if <code>shared_mem_last_arg</code> is provided, it is stored once in shared memory\nand accessible by all workers, avoiding redundant copies of large data arrays.</li>\n<li>Compatible with both standard Python terminals and Jupyter notebooks (adaptive progress bars).</li>\n<li>Intended for internal use by higher-level orchestration functions such as <code>parallel_blocks()</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">funcs</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">all_args</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_blocks</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">pbar_title</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">disable_parallel</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">shared_mem_last_arg</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.parallel_utils.parallel_blocks", "modulename": "bsplyne.parallel_utils", "qualname": "parallel_blocks", "kind": "function", "doc": "<p>Execute a set of independent tasks sequentially or in parallel, depending on their estimated cost.</p>\n\n<p>The function evaluates the runtime of the first task to decide whether parallelization is worth\nthe overhead of process creation. If parallel execution is deemed beneficial, the remaining tasks\nare distributed across several blocks processed in parallel. Otherwise, all tasks are executed\nsequentially. This strategy is especially useful when task runtimes are variable or short compared\nto process spawning costs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>funcs</strong> (Union[Callable, Iterable[Callable]]):\nFunction or list of functions to execute.\n<ul>\n<li>If a single function is provided, it will be applied to each argument tuple in <code>all_args</code>.</li>\n<li>If a list of functions is provided, it must have the same length as <code>all_args</code>, allowing each\ntask to use a distinct callable.</li>\n</ul></li>\n<li><strong>all_args</strong> (Union[Iterable[tuple], None], optional):\nIterable of tuples containing the positional arguments for each function call.\nIf the function takes no arguments, set <code>all_args</code> to <code>None</code> (defaults to empty tuples).</li>\n<li><strong>num_blocks</strong> (Union[int, None], optional):\nNumber of parallel blocks (i.e., worker processes) to use. Defaults to half the number of CPU cores.\nA value of 1 forces sequential execution.</li>\n<li><strong>verbose</strong> (bool, optional):\nIf True, displays timing information and progress bars. Default is True.</li>\n<li><strong>pbar_title</strong> (str, optional):\nTitle prefix displayed in the progress bar. Default is \"Processing blocks\".</li>\n<li><strong>disable_parallel</strong> (bool, optional):\nIf True, forces all computations to run sequentially regardless of estimated profitability.\nDefault is False.</li>\n<li><strong>est_proc_cost</strong> (float, optional):\nEstimated process creation cost in seconds. Used to determine whether parallelization\nwill yield a net speedup. Default is 0.5 s.</li>\n<li><strong>shared_mem_last_arg</strong> (Union[np.ndarray, None], optional):\nShared-memory NumPy array to be appended automatically as the last argument in each task.\nThis allows tasks to read from a large, read-only array without duplicating it in memory.\nDefault is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list</strong>: List of results, one per task, preserving the input order.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The first task is executed sequentially to estimate its runtime.</li>\n<li>Parallelization is enabled only if the estimated time saved exceeds the cost of process creation.</li>\n<li>When parallel mode is used, tasks are executed in blocks, and intermediate results are stored\ntemporarily on disk to limit memory usage, then reloaded and combined sequentially.</li>\n<li>Compatible with Jupyter progress bars (<code>tqdm.notebook</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">funcs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">all_args</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">num_blocks</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">pbar_title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Processing blocks&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">disable_parallel</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">est_proc_cost</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">shared_mem_last_arg</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.save_utils", "modulename": "bsplyne.save_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bsplyne.save_utils.writePVD", "modulename": "bsplyne.save_utils", "qualname": "writePVD", "kind": "function", "doc": "<p>Writes a Paraview Data (PVD) file that references multiple VTK files.</p>\n\n<p>Creates an XML-based PVD file that collects and organizes multiple VTK files into groups,\nallowing visualization of multi-part, time-series data in Paraview.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fileName</strong> (str):\nBase name for the mesh files (without numbers and extension)</li>\n<li><strong>groups</strong> (dict[str, dict]):\nNested dictionary specifying file groups with format:\n{\"group_name\": {\"ext\": \"file_extension\", \"npart\": num_parts, \"nstep\": num_timesteps}}</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>VTK files must follow naming pattern: {fileName}_{group}_{part}_{timestep}.{ext}\nExample: for fileName=\"mesh\", group=\"fluid\", part=1, timestep=5, ext=\"vtu\":\n        mesh_fluid_1_5.vtu</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fileName</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">groups</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.save_utils.merge_meshes", "modulename": "bsplyne.save_utils", "qualname": "merge_meshes", "kind": "function", "doc": "<p>Merges multiple meshio.Mesh objects into a single mesh.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>meshes</strong> (Iterable[io.Mesh]):\nAn iterable of meshio.Mesh objects to merge.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>io.Mesh</strong>: A single meshio.Mesh object containing the merged meshes with combined \nvertices, cells and point data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">meshes</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">meshio</span><span class=\"o\">.</span><span class=\"n\">_mesh</span><span class=\"o\">.</span><span class=\"n\">Mesh</span>:</span></span>", "funcdef": "def"}, {"fullname": "bsplyne.save_utils.merge_saves", "modulename": "bsplyne.save_utils", "qualname": "merge_saves", "kind": "function", "doc": "<p>Merge multiple mesh files and save the merged results.</p>\n\n<p>This function reads multiple mesh files for each group and time step,\nmerges them into a single mesh, and writes the merged mesh to a new file.\nIt also generates a PVD file to describe the collection of merged meshes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nThe directory path where the mesh files are located.</li>\n<li><strong>name</strong> (str):\nThe base name of the mesh files.</li>\n<li><strong>nb_patchs</strong> (int):\nThe number of patches to merge for each group and time step.</li>\n<li><strong>nb_steps</strong> (int):\nThe number of time steps for which meshes are available.</li>\n<li><strong>group_names</strong> (list[str]):\nA list of group names to process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">nb_patchs</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">nb_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">group_names</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();